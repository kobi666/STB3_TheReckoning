<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Animancer.Lite</name>
    </assembly>
    <members>
        <member name="T:Animancer.FastComparer">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which ignores overloaded equality operators so it is faster than
            <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> for types derived from <see cref="T:UnityEngine.Object"/>.
            </summary>
        </member>
        <member name="F:Animancer.FastComparer.Instance">
            <summary>Singleton instance.</summary>
        </member>
        <member name="M:Animancer.FastComparer.System#Collections#Generic#IEqualityComparer{System#Object}#Equals(System.Object,System.Object)">
            <summary>Calls <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.</summary>
        </member>
        <member name="M:Animancer.FastComparer.System#Collections#Generic#IEqualityComparer{System#Object}#GetHashCode(System.Object)">
            <summary>Calls <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="T:Animancer.FastReferenceComparer">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which uses <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> to be even faster than
            <see cref="T:Animancer.FastComparer"/>. Unfortunately this means it will not work for boxed value types (such as enums).
            </summary>
        </member>
        <member name="F:Animancer.FastReferenceComparer.Instance">
            <summary>Singleton instance.</summary>
        </member>
        <member name="M:Animancer.FastReferenceComparer.System#Collections#Generic#IEqualityComparer{System#Object}#Equals(System.Object,System.Object)">
            <summary>Calls <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.</summary>
        </member>
        <member name="M:Animancer.FastReferenceComparer.System#Collections#Generic#IEqualityComparer{System#Object}#GetHashCode(System.Object)">
            <summary>Calls <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="T:Animancer.IKeyHolder">
            <summary>
            An object with a <see cref="T:Animancer.Key"/> so it can be used in a <see cref="T:Animancer.Key.KeyedList`1"/>.
            </summary>
        </member>
        <member name="P:Animancer.IKeyHolder.Key">
            <summary>The <see cref="T:Animancer.Key"/> which stores the list index of this object.</summary>
        </member>
        <member name="T:Animancer.Key">
            <summary>
            Stores the index of an object in a <see cref="T:Animancer.Key.KeyedList`1"/> to allow it to be efficiently removed.
            </summary>
        </member>
        <member name="M:Animancer.Key.IndexOf(Animancer.Key)">
            <summary>Returns location of this object in the list (or -1 if it is not currently in a keyed list).</summary>
        </member>
        <member name="M:Animancer.Key.IsInList(Animancer.Key)">
            <summary>Indicates whether the specified object is currently in a keyed list.</summary>
        </member>
        <member name="P:Animancer.Key.Animancer#IKeyHolder#Key">
            <summary>A <see cref="T:Animancer.Key"/> is its own <see cref="P:Animancer.IKeyHolder.Key"/>.</summary>
        </member>
        <member name="T:Animancer.Key.KeyedList`1">
             <summary>
             A <see cref="T:System.Collections.Generic.List`1"/> which can remove items without needing to search through the entire collection.
             Does not allow nulls to be added.
             </summary>
            
             <example>
             To use an object in a Keyed List, it must either inherit from <see cref="T:Animancer.Key"/> or implement
             <see cref="T:Animancer.IKeyHolder"/> like so:
             <code>
             class MyClass : IKeyHolder
             {
                 private readonly Key Key = new Key();
                 Key IKeyHolder.Key => Key; } }
             }
             </code>
             Note that the <c>Key</c> field can be made <c>public</c> if desired.
             </example>
            
             <remarks>
             This class is nested inside <see cref="T:Animancer.Key"/> so it can modify the private <see cref="F:Animancer.Key._Index"/> without
             exposing that capability to anything else.
             </remarks>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.#ctor">
            <summary>Creates a new <see cref="T:Animancer.Key.KeyedList`1"/> using the default <see cref="T:System.Collections.Generic.List`1"/> constructor.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.#ctor(System.Int32)">
            <summary>Creates a new <see cref="T:Animancer.Key.KeyedList`1"/> with the specified initial `capacity`.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.Count">
            <summary>The number of items currently in the list.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.Capacity">
            <summary>The number of items that this list can contain before resizing is required.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.Item(System.Int32)">
            <summary>Gets or sets the item at the specified `index`.</summary>
            <exception cref="T:System.ArgumentException">The `value` was already in a keyed list (setter only).</exception>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Add(`0)">
            <summary>Adds the `item` to the end of this list.</summary>
            <exception cref="T:System.ArgumentException">The `item` was already in a keyed list.</exception>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.AddNew(`0)">
            <summary>Adds the `item` to the end of this list if it wasn't already in it.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.RemoveAt(System.Int32)">
            <summary>Removes the item at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.RemoveAtSwap(System.Int32)">
            <summary>
            Removes the item at the specified `index` by swapping the last item in this list into its place.
            <para></para>
            This does not maintain the order of items, but is more efficient than <see cref="M:Animancer.Key.KeyedList`1.RemoveAt(System.Int32)"/> because
            it avoids the need to move every item after the target down one place.
            </summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Remove(`0)">
            <summary>Removes the `item` from this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.RemoveSwap(`0)">
            <summary>
            Removes the `item` by swapping the last item in this list into its place.
            <para></para>
            This does not maintain the order of items, but is more efficient than <see cref="M:Animancer.Key.KeyedList`1.Remove(`0)"/> because
            it avoids the need to move every item after the target down one place.
            </summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Clear">
            <summary>Removes all items from this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Contains(`0)">
            <summary>Indicates whether the `item` is currently in this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.IndexOf(`0)">
            <summary>Returns the index of the `item` in this list or -1 if it is not in this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Insert(System.Int32,`0)">
            <summary>Adds the `item` to this list at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies all the items from this list into the `array`, starting at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies all the items from this list into the `array`, starting at the specified `index`.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>Returns false.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through this list.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.System#Collections#ICollection#IsSynchronized">
            <summary>Is this list thread safe?</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.System#Collections#ICollection#SyncRoot">
            <summary>An object that can be used to synchronize access to this <see cref="T:System.Collections.ICollection"/>.</summary>
        </member>
        <member name="T:Animancer.ObjectPool">
            <summary>Convenience methods for accessing <see cref="T:Animancer.ObjectPool`1"/>.</summary>
        </member>
        <member name="M:Animancer.ObjectPool.Acquire``1">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to get a spare item if there are any, or create a new one.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Acquire``1(``0@)">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to get a spare item if there are any, or create a new one.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(``0)">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Release(`0)"/> to add the `item` to the list of spares so it can be reused.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(``0@)">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Release(`0)"/> to add the `item` to the list of spares so it can be reused.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.AcquireList``1">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to get a spare <see cref="T:System.Collections.Generic.List`1"/> if
            there are any or create a new one.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.List{``0})">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Release(`0)"/> to clear the `list` and mark it as a spare
            so it can be later returned by <see cref="M:Animancer.ObjectPool.AcquireList``1"/>.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.AcquireSet``1">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to get a spare <see cref="T:System.Collections.Generic.HashSet`1"/> if
            there are any or create a new one.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.HashSet{``0})">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Release(`0)"/> to clear the `set` and mark it as a spare
            so it can be later returned by <see cref="M:Animancer.ObjectPool.AcquireSet``1"/>.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.AcquireStringBuilder">
            <summary>
            Calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to get a spare <see cref="T:System.Text.StringBuilder"/> if
            there are any or create a new one.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release(System.Text.StringBuilder)">
            <summary>
            Sets <see cref="P:System.Text.StringBuilder.Length"/> = 0 and <see cref="M:Animancer.ObjectPool`1.Release(`0)"/> to mark it as a spare
            so it can be later returned by <see cref="M:Animancer.ObjectPool.AcquireStringBuilder"/>.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.ReleaseToString(System.Text.StringBuilder)">
            <summary>
            Calls <see cref="M:System.Text.StringBuilder.ToString"/> and <see cref="M:Animancer.ObjectPool.Release(System.Text.StringBuilder)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.GetCachedResult``1(System.Func{``0})">
            <summary>
            Creates an object using the provided delegate and caches it so the same style can be returned when this
            method is called again for the same delegate.
            </summary>
        </member>
        <member name="T:Animancer.ObjectPool`1">
            <summary>A simple object pooling system.</summary>
        </member>
        <member name="P:Animancer.ObjectPool`1.Count">
            <summary>The number of spare items currently in the pool.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.SetMinCount(System.Int32)">
            <summary>
            If the <see cref="P:Animancer.ObjectPool`1.Count"/> is less than the specified value, this method increases it to that value by
            creating new objects.
            </summary>
        </member>
        <member name="P:Animancer.ObjectPool`1.Capacity">
            <summary>The <see cref="P:System.Collections.Generic.List`1.Capacity"/> of the internal list of spare items.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.Acquire">
            <summary>Returns a spare item if there are any, or creates a new one.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.Release(`0)">
            <summary>Adds the `item` to the list of spares so it can be reused.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.GetDetails">
            <summary>Returns a description of the state of this pool.</summary>
        </member>
        <member name="T:Animancer.ControllerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which plays a <see cref="T:UnityEngine.RuntimeAnimatorController"/>.
            You can control this state very similarly to an <see cref="T:UnityEngine.Animator"/> via its <see cref="P:Animancer.ControllerState.Playable"/> property.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Controller">
            <summary>The <see cref="T:UnityEngine.RuntimeAnimatorController"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ControllerState.MainObject">
            <summary>The <see cref="T:UnityEngine.RuntimeAnimatorController"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ControllerState.Playable">
            <summary>The internal system which plays the <see cref="T:UnityEngine.RuntimeAnimatorController"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.KeepStateOnStop">
            <summary>
            If false, <see cref="M:Animancer.ControllerState.Stop"/> will reset all layers to their default state. Default False.
            <para></para>
            The <see cref="P:Animancer.ControllerState.DefaultStateHashes"/> will only be gathered the first time this property is set to false or
            <see cref="M:Animancer.ControllerState.GatherDefaultStates"/> is called manually.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.DefaultStateHashes">
            <summary>
            The <see cref="P:UnityEngine.AnimatorStateInfo.shortNameHash"/> of the default state on each layer, used to reset to
            those states when <see cref="M:Animancer.ControllerState.Stop"/> is called if <see cref="P:Animancer.ControllerState.KeepStateOnStop"/> is true.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.UnsupportedEventsMessage">
            <summary>[Assert-Only]
            Animancer Events do not work properly on <see cref="T:Animancer.ControllerState"/>s.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.ApplyAnimatorIK">
            <summary>IK cannot be dynamically enabled on a <see cref="T:Animancer.ControllerState"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,System.Boolean)">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="M:Animancer.ControllerState.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="P:Animancer.ControllerState.Playable"/> managed by this node.</summary>
        </member>
        <member name="M:Animancer.ControllerState.RecreatePlayable">
            <summary>
            Stores the values of all parameters, calls <see cref="M:Animancer.AnimancerNode.DestroyPlayable"/>, then restores the
            parameter values.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.StateInfo">
            <summary>
            The current state on layer 0, or the next state if it is currently in a transition.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.RawTime">
            <summary>
            The <see cref="P:UnityEngine.AnimatorStateInfo.normalizedTime"/> * <see cref="P:UnityEngine.AnimatorStateInfo.length"/> of the
            <see cref="P:Animancer.ControllerState.StateInfo"/>
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Length">
            <summary>The current <see cref="P:UnityEngine.AnimatorStateInfo.length"/> (on layer 0).</summary>
        </member>
        <member name="P:Animancer.ControllerState.IsLooping">
            <summary>
            Indicates whether the current state on layer 0 will loop back to the start when it reaches the end.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.GatherDefaultStates">
            <summary>
            Gathers the <see cref="P:Animancer.ControllerState.DefaultStateHashes"/> from the current states.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Stop">
            <summary>
            Calls the base <see cref="M:Animancer.AnimancerState.Stop"/> and if <see cref="P:Animancer.ControllerState.KeepStateOnStop"/> is false it also
            calls <see cref="M:Animancer.ControllerState.ResetToDefaultStates"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.ResetToDefaultStates">
            <summary>
            Resets all layers to their default state.
            </summary>
            <exception cref="T:System.NullReferenceException"><see cref="P:Animancer.ControllerState.DefaultStateHashes"/> is null.</exception>
            <exception cref="T:System.IndexOutOfRangeException">
            The size of <see cref="P:Animancer.ControllerState.DefaultStateHashes"/> is larger than the number of layers in the
            <see cref="P:Animancer.ControllerState.Controller"/>.
            </exception>
        </member>
        <member name="M:Animancer.ControllerState.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in this state.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Destroy">
            <summary>Destroys the <see cref="P:Animancer.ControllerState.Playable"/> and cleans up this state.</summary>
            <remarks>
            This method is NOT called automatically, so when implementing a custom state type you must use
            <see cref="P:Animancer.AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up.
            </remarks>
        </member>
        <member name="T:Animancer.ControllerState.Parameter">
            <summary>
            A wrapper for the name and hash of an <see cref="T:UnityEngine.AnimatorControllerParameter"/> to allow easy access.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Parameter.Name">
            <summary>
            The name of the wrapped parameter. This will be null if the <see cref="P:Animancer.ControllerState.Parameter.Hash"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Parameter.Hash">
            <summary>
            The name hash of the wrapped parameter.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.#ctor(System.String)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Name"/> and uses
            <see cref="M:UnityEngine.Animator.StringToHash(System.String)"/> to calculate the <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.#ctor(System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Hash"/> and leaves the
            <see cref="P:Animancer.ControllerState.Parameter.Name"/> null.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.op_Implicit(System.String)~Animancer.ControllerState.Parameter">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Name"/> and uses
            <see cref="M:UnityEngine.Animator.StringToHash(System.String)"/> to calculate the <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.op_Implicit(System.Int32)~Animancer.ControllerState.Parameter">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Hash"/> and leaves the
            <see cref="P:Animancer.ControllerState.Parameter.Name"/> null.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.op_Implicit(Animancer.ControllerState.Parameter)~System.Int32">
            <summary>Returns the <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.ValidateHasParameter(UnityEngine.RuntimeAnimatorController,UnityEngine.AnimatorControllerParameterType)">
            <summary>[Editor-Conditional]
            Throws if the `controller` doesn't have a parameter with the specified <see cref="P:Animancer.ControllerState.Parameter.Hash"/>
            and `type`.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.ToString">
            <summary>Returns a string containing the <see cref="P:Animancer.ControllerState.Parameter.Name"/> and <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't wrap any parameters.</exception>
        </member>
        <member name="M:Animancer.ControllerState.CreateDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.ControllerState.Drawer"/> for this state.</summary>
        </member>
        <member name="T:Animancer.ControllerState.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.ControllerState"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.#ctor(Animancer.ControllerState)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Drawer"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.DoDetailsGUI">
            <summary> Draws the details of the target state in the GUI.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GatherParameters">
            <summary>
            Fills the <see cref="F:Animancer.ControllerState.Drawer.Parameters"/> list with the current parameter details.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Drawer.ParameterCount">
            <summary>The number of parameters being managed by the target state.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.ControllerState.Transition`1">
            <summary>
            Base class for serializable <see cref="T:Animancer.ITransition"/>s which can create a particular type of
            <see cref="T:Animancer.ControllerState"/> when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            <para></para>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.ControllerState.Transition`1.Controller">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.ControllerState.Controller"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Transition`1.NormalizedStartTime">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines what <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to start the animation at.
            <para></para>
            The default value is <see cref="F:System.Single.NaN"/> which indicates that this value is not used so the
            animation will continue from its current time.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Transition`1.KeepStateOnStop">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            If false, <see cref="M:Animancer.ControllerState.Stop"/> will reset all layers to their default state.
            <para></para>
            If you set this value to false after the <see cref="P:Animancer.ControllerState.Playable"/> is created, you must assign the
            <see cref="P:Animancer.ControllerState.DefaultStateHashes"/> or call <see cref="M:Animancer.ControllerState.GatherDefaultStates"/> yourself.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Transition`1.MaximumDuration">
            <summary>[<see cref="T:Animancer.ITransitionDetailed"/>]
            The maximum amount of time the animation is expected to take (in seconds).
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Transition`1.IsValid">
            <summary>Indicates whether this transition can create a valid <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition`1.op_Implicit(Animancer.ControllerState.Transition{`0})~UnityEngine.RuntimeAnimatorController">
            <summary>Returns the <see cref="P:Animancer.ControllerState.Transition`1.Controller"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition`1.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> to apply the
            <see cref="P:Animancer.ControllerState.Transition`1.NormalizedStartTime"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition`1.Animancer#IAnimationClipCollection#GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Adds all clips in the <see cref="P:Animancer.ControllerState.Transition`1.Controller"/> to the collection.</summary>
        </member>
        <member name="T:Animancer.ControllerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.ITransition"/> which can create a <see cref="T:Animancer.ControllerState"/> when
            passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            <para></para>
            This class can be implicitly cast to and from <see cref="T:UnityEngine.RuntimeAnimatorController"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ControllerState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method
            as well. Or you can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.#ctor(UnityEngine.RuntimeAnimatorController)">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState.Transition"/> with the specified Animator Controller.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.op_Implicit(UnityEngine.RuntimeAnimatorController)~Animancer.ControllerState.Transition">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState.Transition"/> with the specified Animator Controller.</summary>
        </member>
        <member name="T:Animancer.ControllerState.Transition.Drawer">
            <summary>
            [Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.ControllerState.Transition`1"/> or
            <see cref="T:Animancer.ControllerState.Transition"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.Drawer.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState.Transition.Drawer"/> without any parameters.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.Drawer.#ctor(System.String[])">
            <summary>Constructs a new <see cref="T:Animancer.ControllerState.Transition.Drawer"/> and sets the <see cref="F:Animancer.ControllerState.Transition.Drawer.Parameters"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.Drawer.DoPropertyGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Draws the `property` GUI in relation to the `rootProperty` which was passed into
            <see cref="M:Animancer.Editor.TransitionDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Transition.Drawer.DoParameterGUI(UnityEngine.Rect,UnityEditor.Animations.AnimatorController,UnityEditor.SerializedProperty)">
            <summary>
            Draws a dropdown menu to select the name of a parameter in the `controller`.
            </summary>
        </member>
        <member name="T:Animancer.Float1ControllerState">
            <summary>[Pro-Only]
            A <see cref="T:Animancer.ControllerState"/> which manages one float parameter.
            </summary>
            <remarks>
            See also: <see cref="T:Animancer.Float2ControllerState"/> and <see cref="T:Animancer.Float3ControllerState"/>.
            </remarks>
        </member>
        <member name="P:Animancer.Float1ControllerState.ParameterName">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float1ControllerState.Parameter"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float1ControllerState.ParameterHash"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float1ControllerState.ParameterHash">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float1ControllerState.Parameter"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float1ControllerState.Parameter">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float1ControllerState.ParameterHash"/> as the id.
            </summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>Constructs a new <see cref="T:Animancer.Float1ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="P:Animancer.Float1ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
        </member>
        <member name="T:Animancer.Float1ControllerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.ITransition"/> which can create a <see cref="T:Animancer.Float1ControllerState"/>
            when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.Float1ControllerState.Transition.ParameterName">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float1ControllerState.ParameterName"/> that will be used for the created state.
            </summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.Transition.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.Float1ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.Transition.#ctor(UnityEngine.RuntimeAnimatorController,System.String)">
            <summary>Constructs a new <see cref="T:Animancer.Float1ControllerState.Transition"/> with the specified Animator Controller and parameter.</summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.Transition.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.Float1ControllerState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method
            as well. Or you can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.Float1ControllerState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.Float1ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.Transition.Drawer.#ctor">
            <summary>
            Constructs a new <see cref="T:Animancer.Float1ControllerState.Transition.Drawer"/> and sets the
            <see cref="F:Animancer.ControllerState.Transition.Drawer.Parameters"/>.
            </summary>
        </member>
        <member name="T:Animancer.Float2ControllerState">
            <summary>[Pro-Only]
            A <see cref="T:Animancer.ControllerState"/> which manages two float parameters.
            </summary>
            <remarks>
            See also: <see cref="T:Animancer.Float1ControllerState"/> and <see cref="T:Animancer.Float3ControllerState"/>.
            </remarks>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterNameX">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float2ControllerState.ParameterX"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float2ControllerState.ParameterHashX"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterHashX">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float2ControllerState.ParameterX"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterX">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float2ControllerState.ParameterHashX"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterNameY">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float2ControllerState.ParameterY"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float2ControllerState.ParameterHashY"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterHashY">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float2ControllerState.ParameterY"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterY">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float2ControllerState.ParameterHashY"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.Parameter">
            <summary>
            Gets and sets <see cref="P:Animancer.Float2ControllerState.ParameterX"/> and <see cref="P:Animancer.Float2ControllerState.ParameterY"/>.
            </summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>Constructs a new <see cref="T:Animancer.Float2ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
        </member>
        <member name="T:Animancer.Float2ControllerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.ITransition"/> which can create a <see cref="T:Animancer.Float2ControllerState"/>
            when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.Float2ControllerState.Transition.ParameterNameX">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float2ControllerState.ParameterNameX"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.Transition.ParameterNameY">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float2ControllerState.ParameterNameY"/> that will be used for the created state.
            </summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.Transition.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.Float2ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.Transition.#ctor(UnityEngine.RuntimeAnimatorController,System.String,System.String)">
            <summary>Constructs a new <see cref="T:Animancer.Float2ControllerState.Transition"/> with the specified Animator Controller and parameters.</summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.Transition.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.Float2ControllerState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method
            as well. Or you can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.Float2ControllerState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.Float2ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.Transition.Drawer.#ctor">
            <summary>
            Constructs a new <see cref="T:Animancer.Float2ControllerState.Transition.Drawer"/> and sets the
            <see cref="F:Animancer.ControllerState.Transition.Drawer.Parameters"/>.
            </summary>
        </member>
        <member name="T:Animancer.Float3ControllerState">
            <summary>[Pro-Only]
            A <see cref="T:Animancer.ControllerState"/> which manages three float parameters.
            </summary>
            <remarks>
            See also: <see cref="T:Animancer.Float1ControllerState"/> and <see cref="T:Animancer.Float2ControllerState"/>.
            </remarks>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterNameX">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterX"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float3ControllerState.ParameterHashX"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterHashX">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterX"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterX">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float3ControllerState.ParameterHashX"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterNameY">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterY"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float3ControllerState.ParameterHashY"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterHashY">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterY"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterY">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float3ControllerState.ParameterHashY"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterNameZ">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterZ"/> will get and set.
            This will be null if the <see cref="P:Animancer.Float3ControllerState.ParameterHashZ"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterHashZ">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterZ"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterZ">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float3ControllerState.ParameterHashZ"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.Parameter">
            <summary>
            Gets and sets <see cref="P:Animancer.Float3ControllerState.ParameterX"/>, <see cref="P:Animancer.Float3ControllerState.ParameterY"/>, and <see cref="P:Animancer.Float3ControllerState.ParameterZ"/>.
            </summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,System.Boolean)">
            <summary>Constructs a new <see cref="T:Animancer.Float3ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
        </member>
        <member name="T:Animancer.Float3ControllerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.ITransition"/> which can create a <see cref="T:Animancer.Float3ControllerState"/>
            when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.Float3ControllerState.Transition.ParameterNameX">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float3ControllerState.ParameterNameX"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.Transition.ParameterNameY">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float3ControllerState.ParameterNameY"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.Transition.ParameterNameZ">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.Float3ControllerState.ParameterNameZ"/> that will be used for the created state.
            </summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.Transition.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.Float3ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.Transition.#ctor(UnityEngine.RuntimeAnimatorController,System.String,System.String,System.String)">
            <summary>Constructs a new <see cref="T:Animancer.Float3ControllerState.Transition"/> with the specified Animator Controller and parameters.</summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.Transition.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.Float3ControllerState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method
            as well. Or you can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.Float3ControllerState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.Float3ControllerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.Transition.Drawer.#ctor">
            <summary>
            Constructs a new <see cref="T:Animancer.Float3ControllerState.Transition.Drawer"/> and sets the
            <see cref="F:Animancer.ControllerState.Transition.Drawer.Parameters"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerEvent">
            <summary>
            A <see cref="F:Animancer.AnimancerEvent.callback"/> delegate paired with a <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to determine when to invoke it.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.normalizedTime">
            <summary>The <see cref="P:Animancer.AnimancerState.NormalizedTime"/> at which to invoke the <see cref="F:Animancer.AnimancerEvent.callback"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.callback">
            <summary>The delegate to invoke when the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> passes.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.AlmostOne">
            <summary>The largest possible float value less than 1.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.#ctor(System.Single,System.Action)">
            <summary>Constructs a new <see cref="T:Animancer.AnimancerEvent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.ToString">
            <summary>Returns "AnimancerEvent(normalizedTime, callback)".</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.AppendDetails(System.Text.StringBuilder,System.String,System.String)">
            <summary>Appends the details of this event to the `text`.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.CurrentState">
            <summary>The <see cref="T:Animancer.AnimancerState"/> currently triggering an event using <see cref="M:Animancer.AnimancerEvent.Invoke(Animancer.AnimancerState)"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.CurrentEvent">
            <summary>The <see cref="T:Animancer.AnimancerEvent"/> currently being triggered by <see cref="M:Animancer.AnimancerEvent.Invoke(Animancer.AnimancerState)"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Invoke(Animancer.AnimancerState)">
            <summary>
            Sets the static <see cref="P:Animancer.AnimancerEvent.CurrentState"/> and <see cref="P:Animancer.AnimancerEvent.CurrentEvent"/> then invokes the <see cref="F:Animancer.AnimancerEvent.callback"/>.
            <para></para>
            This method catches and logs any exception thrown by the <see cref="F:Animancer.AnimancerEvent.callback"/>.
            </summary>
            <exception cref="T:System.NullReferenceException">The <see cref="F:Animancer.AnimancerEvent.callback"/> is null.</exception>
        </member>
        <member name="M:Animancer.AnimancerEvent.GetFadeOutDuration(System.Single)">
            <summary>
            Returns either the `minDuration` or the <see cref="P:Animancer.AnimancerState.RemainingDuration"/> of the
            <see cref="P:Animancer.AnimancerEvent.CurrentState"/> state (whichever is higher).
            </summary>
        </member>
        <member name="T:Animancer.AnimancerEvent.Sequence">
            <summary>
            A variable-size list of <see cref="T:Animancer.AnimancerEvent"/>s which keeps itself sorted according to their
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>.
            <para></para>
            Animancer Lite does not allow the use of events in a runtime build, except for <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.NoEvents">
            <summary>
            A zero length array of <see cref="T:Animancer.AnimancerEvent"/>s which is used by all sequence before any elements
            are added to them (unless their <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is set manually).
            </summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence._Events">
            <summary>All of the <see cref="T:Animancer.AnimancerEvent"/>s in this sequence (excluding the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>).</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Count">
            <summary>[Pro-Only] The number of events in this sequence (excluding the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>).</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.IsEmpty">
            <summary>Indicates whether the sequence has any events in it (including the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>).</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.DefaultCapacity">
            <summary>The initial <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> that will be used if another value is not specified.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Capacity">
            <summary>[Pro-Only]
            The size of the internal array used to hold events.
            <para></para>
            When set, the array is reallocated to the given size.
            <para></para>
            By default, the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> starts at 0 and increases to the <see cref="F:Animancer.AnimancerEvent.Sequence.DefaultCapacity"/>
            when the first event is added.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Version">
            <summary>[Pro-Only]
            The number of times the contents of this sequence have been modified. This applies to general events,
            but not the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.endEvent">
             <summary>
             A <see cref="F:Animancer.AnimancerEvent.callback"/> that will be triggered every frame after the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> has
             passed. If you want it to only get triggered once, you can either have the event clear itself or just
             use a regular event instead.
             <para></para>
             Interrupting the animation does not trigger this event.
             <para></para>
             By default, the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> will be <see cref="F:System.Single.NaN"/> so that it can choose the
             correct value based on the current play direction: forwards ends at 1 and backwards ends at 0.
             <para></para>
             Animancer Lite does not allow the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to be changed in Runtime Builds.
             </summary>
            
             <example><code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
                 state.Events.NormalizedEndTime = 0.75f;
                 state.Events.OnEnd = OnAnimationEnd;
            
                 // Or set the time and callback at the same time:
                 state.Events.endEvent = new AnimancerEvent(0.75f, OnAnimationEnd);
             }
            
             void OnAnimationEnd()
             {
                 Debug.Log("Animation ended");
             }
             </code></example>
            
             <remarks>
             See the documentation for more information about
             <see href="https://kybernetik.com.au/animancer/docs/manual/events/end">
             End Events</see>.
             </remarks>
             
             <seealso cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/>
             <seealso cref="P:Animancer.AnimancerEvent.Sequence.NormalizedEndTime"/>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.OnEnd">
            <summary>Shorthand for the <c>endEvent.callback</c>.</summary>
            <seealso cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>
            <seealso cref="P:Animancer.AnimancerEvent.Sequence.NormalizedEndTime"/>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.NormalizedEndTime">
            <summary>[Pro-Only] Shorthand for <c>endEvent.normalizedTime</c>.</summary>
            <seealso cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>
            <seealso cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.GetDefaultNormalizedStartTime(System.Single)">
            <summary>
            The default <see cref="P:Animancer.AnimancerState.NormalizedTime"/> for an animation to start at when playing
            forwards is 0 (the start of the animation) and when playing backwards is 1 (the end of the animation).
            <para></para>
            `speed` 0 or <see cref="F:System.Single.NaN"/> will also return 0.
            </summary>
            <remarks>
            This method has nothing to do with events, so it is only here because of
            <see cref="M:Animancer.AnimancerEvent.Sequence.GetDefaultNormalizedEndTime(System.Single)"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.GetDefaultNormalizedEndTime(System.Single)">
            <summary>
            The default <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> for an <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/> when playing forwards is 1 (the
            end of the animation) and when playing backwards is 0 (the start of the animation).
            <para></para>
            `speed` 0 or <see cref="F:System.Single.NaN"/> will also return 1.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Names">
            <summary>[Pro-Only] The names of the events (excluding the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>).</summary>
            <remarks>This array can be null and <see cref="M:Animancer.AnimancerEvent.Sequence.GetName(System.Int32)"/> will return null for any missing elements.</remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.GetName(System.Int32)">
            <summary>[Pro-Only]
            Returns the name of the event at the specified `index` or null if it is not included in the <see cref="P:Animancer.AnimancerEvent.Sequence.Names"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.SetName(System.Int32,System.String)">
            <summary>[Pro-Only]
            Sets the name of the event at the specified `index`. If the <see cref="P:Animancer.AnimancerEvent.Sequence.Names"/> did not previously
            include that `index` it will be resized with a size equal to the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.IndexOf(System.String)">
            <summary>[Pro-Only]
            Returns the index of the event with the specified `name` or -1 if there is no such event.
            </summary>
            <seealso cref="P:Animancer.AnimancerEvent.Sequence.Names"/>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.GetName(System.Int32)"/>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.SetName(System.Int32,System.String)"/>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.String)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.String)">
            <summary>[Pro-Only]
            Returns the index of the event with the specified `name` or throws an <see cref="T:System.ArgumentException"/>
            if there is no such event.
            </summary>
            <exception cref="T:System.ArgumentException"/>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOf(System.String)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor">
            <summary>
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/> which starts at 0 <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>.
            <para></para>
            Adding anything to the sequence will set the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> = <see cref="F:Animancer.AnimancerEvent.Sequence.DefaultCapacity"/>
            and then double it whenever the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> would exceed the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor(System.Int32)">
            <summary>[Pro-Only]
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/> which starts with the specified <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>. It will be
            initially empty, but will have room for the given number of elements before any reallocations are
            required.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor(Animancer.AnimancerEvent.Sequence)">
            <summary>
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/> and copies the contents of `copyFrom` into it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor(System.Collections.Generic.ICollection{Animancer.AnimancerEvent})">
            <summary>[Pro-Only]
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/>, copying and sorting the contents of the `collection` into it.
            The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> and <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> will be equal to the
            <see cref="P:System.Collections.Generic.ICollection`1.Count"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor(System.Collections.Generic.IEnumerable{Animancer.AnimancerEvent})">
            <summary>[Pro-Only]
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/>, copying and sorting the contents of the `enumerable` into it.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Item(System.Int32)">
            <summary>[Pro-Only] Returns the event at the specified `index`.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Item(System.String)">
            <summary>[Pro-Only] Returns the event with the specified `name`.</summary>
            <exception cref="T:System.ArgumentException">There is no event with the specified `name`.</exception>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AssertNormalizedTimes">
            <summary>[Assert-Conditional]
            Throws an <see cref="T:System.ArgumentOutOfRangeException"/> if the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> of any events
            is less than 0 or greater than or equal to 1.
            <para></para>
            This does not include the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/> since it works differently to other events.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AssertNormalizedTimes(System.Boolean)">
            <summary>[Assert-Conditional]
            Calls <see cref="M:Animancer.AnimancerEvent.Sequence.AssertNormalizedTimes"/> if `isLooping` is true.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.DeepToString(System.Boolean)">
            <summary>Returns a string containing the details of all events in this sequence.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.GetEnumerator">
            <summary>[Pro-Only] Returns an <see cref="T:Animancer.AnimancerEvent.Sequence.Enumerator"/> for this sequence.</summary>
        </member>
        <member name="T:Animancer.AnimancerEvent.Sequence.Enumerator">
            <summary>[Pro-Only]
            An iterator that can cycle through every event in a <see cref="F:Animancer.AnimancerEvent.Sequence.Enumerator.Sequence"/> except for the
            <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Enumerator.Sequence">
            <summary>The target <see cref="T:Animancer.AnimancerEvent.Sequence"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Enumerator.Current">
            <summary>The event this iterator is currently pointing to.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Enumerator.System#Collections#IEnumerator#Current">
            <summary>The event this iterator is currently pointing to.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Enumerator.#ctor(Animancer.AnimancerEvent.Sequence)">
            <summary>Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence.Enumerator"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Enumerator.MoveNext">
            <summary>
            Moves to the next event in the <see cref="F:Animancer.AnimancerEvent.Sequence.Enumerator.Sequence"/> and returns true if there is one.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="P:Animancer.AnimancerEvent.Sequence.Version"/> has changed since this iterator was created.
            </exception>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            Returns this iterator to the start of the <see cref="F:Animancer.AnimancerEvent.Sequence.Enumerator.Sequence"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="P:Animancer.AnimancerEvent.Sequence.Version"/> has changed since this iterator was created.
            </exception>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(Animancer.AnimancerEvent)">
            <summary>[Pro-Only]
            Adds the given event to this sequence. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            <para></para>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to keep the sequence sorted in ascending order. If there are already any
            events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(System.Single,System.Action)">
            <summary>[Pro-Only]
            Adds the given event to this sequence. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            <para></para>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to keep the sequence sorted in ascending order. If there are already any
            events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(System.Int32,Animancer.AnimancerEvent)">
            <summary>[Pro-Only]
            Adds the given event to this sequence. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            <para></para>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to keep the sequence sorted in ascending order. If there are already any
            events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(System.Int32,System.Single,System.Action)">
            <summary>[Pro-Only]
            Adds the given event to this sequence. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            <para></para>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to keep the sequence sorted in ascending order. If there are already any
            events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AddRange(System.Collections.Generic.IEnumerable{Animancer.AnimancerEvent})">
            <summary>[Pro-Only]
            Adds every event in the `enumerable` to this sequence. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if
            required, the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            <para></para>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to keep the sequence sorted in ascending order. If there are already any
            events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AddCallback(System.Int32,System.Action)">
            <summary>[Pro-Only]
            Adds the specified `callback` to the <see cref="F:Animancer.AnimancerEvent.callback"/> of the event at the specified `index`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AddCallback(System.String,System.Action)">
            <summary>[Pro-Only]
            Adds the specified `callback` to the <see cref="F:Animancer.AnimancerEvent.callback"/> of the event with the specified `name`.
            </summary>
            <exception cref="T:System.ArgumentException">There is no event with the specified `name`.</exception>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.String)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.SetCallback(System.Int32,System.Action)">
            <summary>[Pro-Only]
            Replaces the <see cref="F:Animancer.AnimancerEvent.callback"/> of the event at the specified `index`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.SetCallback(System.String,System.Action)">
            <summary>[Pro-Only]
            Replaces the <see cref="F:Animancer.AnimancerEvent.callback"/> of the event with the specified `name`.
            </summary>
            <exception cref="T:System.ArgumentException">There is no event with the specified `name`.</exception>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.String)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AssertEventUniqueness(System.Action,System.Action)">
            <summary>[Assert-Conditional]
            Logs a warning if the `oldCallback` is identical to the `newCallback` using
            <see cref="F:Animancer.WarningType.DuplicateEvent"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AssertEventUniqueness(System.Int32,Animancer.AnimancerEvent)">
            <summary>[Assert-Conditional]
            Logs a warning if the event at the specified `index` is identical to the `newEvent`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Insert(System.Single)">
            <summary>[Pro-Only]
            Determines the index where a new event with the specified `normalizedTime` should be added in order to
            keep this sequence sorted, increases the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> by one, doubles the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>
            if required, moves any existing events to open up the chosen index, and returns that index.
            <para></para>
            This overload starts searching for the desired index from the end of the sequence, using the assumption
            that elements will usually be added in order.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Insert(System.Int32,System.Single)">
            <summary>[Pro-Only]
            Determines the index where a new event with the specified `normalizedTime` should be added in order to
            keep this sequence sorted, increases the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> by one, doubles the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>
            if required, moves any existing events to open up the chosen index, and returns that index.
            <para></para>
            This overload starts searching for the desired index from the `hint`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Insert(System.Int32)">
            <summary>[Pro-Only]
            Increases the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> by one, doubles the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> if required, and moves any
            existing events to open up the `index`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Remove(System.Int32)">
            <summary>[Pro-Only]
            Removes the event at the specified `index` from this sequence by decrementing the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/>
            and copying all events after the removed one down one place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Remove(System.String)">
            <summary>[Pro-Only]
            Removes the event with the specified `name` from this sequence by decrementing the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/>
            and copying all events after the removed one down one place. Returns true if the event was found and
            removed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Remove(Animancer.AnimancerEvent)">
            <summary>[Pro-Only]
            Removes the `animancerEvent` from this sequence by decrementing the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> and copying all
            events after the removed one down one place. Returns true if the event was found and removed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.RemoveAll">
            <summary>[Pro-Only] Removes all events except the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.</summary>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.Clear"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Clear">
            <summary>Removes all events, including the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.</summary>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.RemoveAll"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.CopyFrom(Animancer.AnimancerEvent.Sequence)">
            <summary>
            Copies all the events from the `source` to replace the previous contents of this sequence.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.CopyTo(Animancer.AnimancerEvent[],System.Int32)">
            <summary>[<see cref="T:System.Collections.Generic.ICollection`1"/>]
            Copies all the events from this sequence into the `array`, starting at the `index`.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerEvent.Sequence.Serializable">
            <summary>
            An <see cref="T:Animancer.AnimancerEvent.Sequence"/> that can be serialized and uses
            <see cref="T:UnityEngine.Events.UnityEvent"/>s to define the <see cref="F:Animancer.AnimancerEvent.callback"/>s.
            </summary>
            <remarks>
            If you have Animancer Pro you can replace <see cref="T:UnityEngine.Events.UnityEvent"/>s with
            <see href="https://kybernetik.com.au/ultevents">UltEvents</see> using the following procedure:
            <list type="number">
            <item>Select the <c>Assets/Plugins/Animancer/Animancer.asmdef</c> and add a Reference to the
            <c>UltEvents</c> Assembly Definition.</item>
            <item>Go into the Player Settings of your project and add <c>ANIMANCER_ULT_EVENTS</c> as a Scripting
            Define Symbol. Or you can simply edit this script to change the event type (it is located at
            <c>Assets/Plugins/Animancer/Internal/Core/AnimancerEvent.Sequence.Serializable.cs</c> by default.</item>
            </list>
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable._Names">
            <summary>The serialized <see cref="P:Animancer.AnimancerEvent.Sequence.Names"/>s.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable._NormalizedTimes">
            <summary>The serialized <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>s.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable._Callbacks">
            <summary>The serialized <see cref="F:Animancer.AnimancerEvent.callback"/>s.</summary>
            <remarks>
            This array only needs to be large enough to hold the last event that actually contains any calls.
            Any empty or missing elements will simply use the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable.DummyCallback"/> at runtime.
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable.NamesField">
            <summary>[Editor-Only] [Internal] The name of the array field which stores the serialized <see cref="P:Animancer.AnimancerEvent.Sequence.Names"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable.NormalizedTimesField">
            <summary>[Editor-Only] [Internal] The name of the array field which stores the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>s.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable.CallbacksField">
            <summary>[Editor-Only] [Internal] The name of the array field which stores the serialized <see cref="F:Animancer.AnimancerEvent.callback"/>s.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Serializable.Sequence">
            <summary>
            The runtime <see cref="T:Animancer.AnimancerEvent.Sequence"/> compiled from this <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.
            Each call after the first will return the same value.
            <para></para>
            Unlike <see cref="M:Animancer.AnimancerEvent.Sequence.Serializable.GetSequenceOptional"/>, this method will create an empty
            <see cref="T:Animancer.AnimancerEvent.Sequence"/> instead of returning null.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetSequenceOptional">
            <summary>
            Returns the runtime <see cref="T:Animancer.AnimancerEvent.Sequence"/> compiled from this
            <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>. Each call after the first will return the same value.
            <para></para>
            This method returns null if the sequence would be empty anyway and is used by the implicit
            conversion from <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/> to <see cref="T:Animancer.AnimancerEvent.Sequence"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.op_Implicit(Animancer.AnimancerEvent.Sequence.Serializable)~Animancer.AnimancerEvent.Sequence">
            <summary>Calls <see cref="M:Animancer.AnimancerEvent.Sequence.Serializable.GetSequenceOptional"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable.DummyCallback">
            <summary>
            A delegate that does nothing which is used whenever the <see cref="T:UnityEngine.Events.UnityEvent"/> is not
            defined for a particular event or it is empty.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetInvoker(UnityEngine.Events.UnityEvent)">
            <summary>
            If the `callback` has any persistent calls, this method returns a delegate to call its
            <see cref="M:UnityEngine.Events.UnityEvent.Invoke"/> method. Otherwise it returns the
            <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable.DummyCallback"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.HasPersistentCalls(UnityEngine.Events.UnityEvent)">
            <summary>
            Determines if the `callback` contains any method calls that will be serialized (otherwise the
            <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable.DummyCallback"/> can be used instead of creating a new delegate to invoke the empty
            `callback`).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.HasPersistentCalls(System.Object)">
            <summary>
            Determines if the `callback` contains any method calls that will be serialized (otherwise the
            <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable.DummyCallback"/> can be used instead of creating a new delegate to invoke the empty
            `callback`).
            <para></para>
            This method casts the `callback` to <see cref="T:UnityEngine.Events.UnityEvent"/> so the caller does not need
            to know what type is actually being used.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetNormalizedEndTime(System.Single)">
            <summary>
            Returns the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> of the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.
            <para></para>
            If the value is not set, the value is determined by <see cref="M:Animancer.AnimancerEvent.Sequence.GetDefaultNormalizedEndTime(System.Single)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetSerializedDetails(System.Int32@,System.Int32@,System.Int32@)">
            <summary>[Internal] Gets the internal details of the specified `serializable`.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.UnityEngine#ISerializationCallbackReceiver#OnAfterDeserialize">
            <summary>[Editor-Only] Clears the <see cref="P:Animancer.AnimancerEvent.Sequence.Serializable.Sequence"/> so it can be recreated when necessary.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.UnityEngine#ISerializationCallbackReceiver#OnBeforeSerialize">
            <summary>[Editor-Only] Ensures that the events are sorted by time (excluding the end event).</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.DynamicSwap``1(``0[]@,System.Int32)">
            <summary>
            Swaps <c>array[index]</c> with <c>array[index - 1]</c> while accounting for the possibility of the
            `index` being beyond the bounds of the `array`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.Trim``1(``0[]@,System.Func{``0,System.Boolean})">
            <summary>Removes unimportant values from the end of the `array`.</summary>
        </member>
        <member name="T:Animancer.Editor.SerializableCallbackHolder">
            <summary>[Editor-Only] [Internal]
            A serializable container which holds a <see cref="T:UnityEngine.Events.UnityEvent"/> in a field named "_Callback".
            </summary>
            <remarks>
            <see cref="T:Animancer.Editor.DummySerializableCallback"/> needs to be in a file with the same name as it (otherwise it can't
            draw the callback properly) and this class needs to be in the same file as
            <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/> to use the <see cref="T:UnityEngine.Events.UnityEvent"/> alias.
            </remarks>
        </member>
        <member name="F:Animancer.Editor.SerializableCallbackHolder.CallbackField">
            <summary>The name of the field which stores the <see cref="T:UnityEngine.Events.UnityEvent"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.SoloAnimationEditor._Animators">
            <summary>The animator referenced by each target.</summary>
        </member>
        <member name="F:Animancer.Editor.SoloAnimationEditor._SerializedAnimator">
            <summary>A <see cref="T:UnityEditor.SerializedObject"/> encapsulating the <see cref="F:Animancer.Editor.SoloAnimationEditor._Animators"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.SoloAnimationEditor._KeepStateOnDisable">
            <summary>The <see cref="P:UnityEngine.Animator.keepAnimatorControllerStateOnDisable"/> property.</summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.DoSerializedFieldsGUI">
            <summary>
            Draws the target's serialized fields.
            </summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.DoStopOnDisableGUI">
            <summary>
            Draws a toggle inverted from the <see cref="P:UnityEngine.Animator.keepAnimatorControllerStateOnDisable"/> field.
            </summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.DoRuntimeDetailsGUI">
            <summary>Draws the target's runtime details.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerEditorUtilities">
            <summary>[Editor-Only] Various utilities used throughout Animancer.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.GetComponentInHierarchy``1(UnityEngine.GameObject)">
            <summary>
            Tries to find a <typeparamref name="T"/> component on the `gameObject` or its parents or children (in that
            order).
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.ShouldAllowReference(UnityEngine.Object,UnityEngine.Object)">
            <summary>Assets cannot reference scene objects.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.GetIsInspectorExpanded(UnityEngine.Object)">
            <summary>Wraps <see cref="M:UnityEditorInternal.InternalEditorUtility.GetIsInspectorExpanded(UnityEngine.Object)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.SetIsInspectorExpanded(UnityEngine.Object,System.Boolean)">
            <summary>Wraps <see cref="M:UnityEditorInternal.InternalEditorUtility.SetIsInspectorExpanded(UnityEngine.Object,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.SetIsInspectorExpanded(UnityEngine.Object[],System.Boolean)">
            <summary>Calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.SetIsInspectorExpanded(UnityEngine.Object,System.Boolean)"/> on all `objects`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.Invoke(System.Object,System.String)">
            <summary>
            Tries to find a method with the specified name on the `target` object and invoke it.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.Invoke(System.Type,System.Object,System.String)">
            <summary>
            Tries to find a method with the specified name on the `target` object and invoke it.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalIssue(System.Action{System.Text.StringBuilder})">
            <summary>
            Registers a delegate that can construct a description of an issue at a later time so that it doesn't waste
            the user's time on unimportant issues.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalMissingType(System.String)">
            <summary>
            Calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalIssue(System.Action{System.Text.StringBuilder})"/> with an issue indicating that a particular type was not
            found by reflection.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalMissingMember(System.String,System.String)">
            <summary>
            Calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalIssue(System.Action{System.Text.StringBuilder})"/> with an issue indicating that a particular member was not
            found by reflection.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AppendNonCriticalIssues(System.Text.StringBuilder)">
            <summary>
            Appends all issues given to <see cref="M:Animancer.Editor.AnimancerEditorUtilities.RegisterNonCriticalIssue(System.Action{System.Text.StringBuilder})"/> to the `text`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.EditModeDelayCall(System.Action)">
            <summary>
            Waits one frame to call the `method` as long as Unity is currently in Edit Mode.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.FindAssetOfType``1">
            <summary>Finds an asset of the specified type anywhere in the project.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RemoveDestroyedObjects``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Removes any items from the `dictionary` that use destroyed objects as their key.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.InitialiseCleanDictionary``2(System.Collections.Generic.Dictionary{``0,``1}@)">
            <summary>
            Creates a new dictionary and returns true if it was null or calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.RemoveDestroyedObjects``2(System.Collections.Generic.Dictionary{``0,``1})"/> and
            returns false if it wasn't.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AddMenuItem(UnityEditor.GenericMenu,System.String,System.Boolean,UnityEditor.GenericMenu.MenuFunction)">
            <summary>
            Adds a menu function which is disabled if `isEnabled` is false.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AddFadeFunction(UnityEditor.GenericMenu,System.String,System.Boolean,Animancer.AnimancerNode,System.Action{System.Single})">
            <summary>
            Adds a menu function which passes the result of <see cref="M:Animancer.Editor.AnimancerEditorUtilities.CalculateEditorFadeDuration(Animancer.AnimancerNode,System.Single)"/> into `startFade`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.CalculateEditorFadeDuration(Animancer.AnimancerNode,System.Single)">
            <summary>
            Returns the duration of the `node`s current fade (if any), otherwise returns the `defaultDuration`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AddDocumentationLink(UnityEditor.GenericMenu,System.String,System.String)">
            <summary>
            Adds a menu function to open a web page. If the `linkSuffix` starts with a '/' then it will be relative to
            the <see cref="F:Animancer.Strings.DocumentationURL"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.ToggleLooping(UnityEditor.MenuCommand)">
            <summary>Toggles the <see cref="P:UnityEngine.Motion.isLooping"/> flag between true and false.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.SetLooping(UnityEngine.AnimationClip,System.Boolean)">
            <summary>Sets the <see cref="P:UnityEngine.Motion.isLooping"/> flag.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.ToggleLegacy(UnityEditor.MenuCommand)">
            <summary>Swaps the <see cref="P:UnityEngine.AnimationClip.legacy"/> flag between true and false.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RestoreBindPose(UnityEditor.MenuCommand)">
            <summary>Calls <see cref="M:UnityEngine.Animator.Rebind"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent">
            <summary>[Editor-Only]
            An <see cref="T:Animancer.IAnimancerComponent"/> that is not actually a <see cref="T:UnityEngine.Component"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.#ctor(UnityEngine.Animator,Animancer.AnimancerPlayable)">
            <summary>Creates a new <see cref="T:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.enabled">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns true.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.gameObject">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns the <see cref="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.Animator"/>'s <see cref="T:UnityEngine.GameObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.Animator">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] The target <see cref="T:UnityEngine.Animator"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.Playable">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] The target <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.IsPlayableInitialised">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns true.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.ResetOnDisable">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns false.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.UpdateMode">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Does nothing.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.GetKey(UnityEngine.AnimationClip)">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns the `clip`.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.AnimatorFieldName">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns null.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.ActionOnDisableFieldName">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns null.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.InitialUpdateMode">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns null.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.TopologicalSort``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.IEqualityComparer{``0},System.Boolean)">
            <summary>
            Sorts an array according to an array of dependants.
            If ItemA depends on ItemB, ItemA will be put later in the returned list.
            </summary>
            <param name="collection">The collection to sort. If any element depends on something that isn't present, it will be added automatically.</param>
            <param name="getDependancies">A delegate that can return the dependancies of any given element.</param>
            <param name="comparer">The equality comparer to use. Null will use the default comparer.</param>
            <param name="ignoreCycles">If false, an <see cref="T:System.ArgumentException"/> will be thrown when a cyclic dependancy is encountered</param>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.TopologicalSort``1(System.Collections.Generic.List{``0},System.Int32,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.IEqualityComparer{``0},System.Boolean)">
            <summary>
            Sorts an array according to an array of dependants.
            If ItemA depends on ItemB, ItemA will be put later in the returned list.
            </summary>
            <param name="list">The list to sort. If any element depends on something that isn't present, it will be added automatically.</param>
            <param name="skip">The index at which to start sorting. Everything before this index is kept in the same order as the input list.</param>
            <param name="getDependancies">A delegate that can return the dependancies of any given element.</param>
            <param name="comparer">The equality comparer to use. Null will use the default comparer.</param>
            <param name="ignoreCycles">If false, an <see cref="T:System.ArgumentException"/> will be thrown when a cyclic dependancy is encountered</param>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.TopologicalSort``1(System.Collections.Generic.List{``0}@,System.Int32,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.IEqualityComparer{``0},System.Boolean)">
            <summary>
            Sorts an array according to an array of dependants.
            If ItemA depends on ItemB, ItemA will be put later in the returned list.
            This method assigns a new list and releases the old one to the CollectionPool.
            </summary>
            <param name="list">The list to sort. If any element depends on something that isn't present, it will be added automatically.</param>
            <param name="skip">The index at which to start sorting. Everything before this index is kept in the same order as the input list.</param>
            <param name="getDependancies">A delegate that can return the dependancies of any given element.</param>
            <param name="comparer">The equality comparer to use. Null will use the default comparer.</param>
            <param name="ignoreCycles">If false, an <see cref="T:System.ArgumentException"/> will be thrown when a cyclic dependancy is encountered</param>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.GameObject)">
             <summary>
             Takes a `gameObject` and returns the root <see cref="T:UnityEngine.Transform"/> of the character it is part of.
             <para></para>
             This method first searches all parents for an <see cref="T:Animancer.ICharacterRoot"/>. If it finds one, it returns the
             <see cref="P:Animancer.ICharacterRoot.transform"/>.
             <para></para>
             Otherwise, if the object is part of a prefab then it returns the root of that prefab instance.
             <para></para>
             Otherwise, it counts the number of <see cref="T:UnityEngine.Animator"/>s in the children of the `gameObject` then does
             the same for each parent. If it finds a parent with a different number of child <see cref="T:UnityEngine.Animator"/>s, it
             assumes that object is the parent of multiple characters and returns the previous parent as the root.
             </summary>
            
             <example>
             <h2>Simple Hierarchy</h2>
             <code>    - Character - Rigidbody, etc.
                 - Model - Animator, AnimancerComponent
                 - States - Various components which reference the AnimationClips they will play</code>
             Passing the <c>Model</c> into this method will return the <c>Character</c> because it has the same
             number of <see cref="T:UnityEngine.Animator"/> components in its children.
            
             <h2>Shared Hierarchy</h2>
             <code>    - Characters - Empty object used to group all characters
                 - Character - Rigidbody, etc.
                     - Model - Animator, AnimancerComponent
                     - States - Various components which reference the AnimationClips they will play
                 - Another Character
                     - Model
                     - States</code>
             <list type="bullet">
             <item><c>Model</c> has one <see cref="T:UnityEngine.Animator"/> and no more in its children.</item>
             <item>And <c>Character</c> has one <see cref="T:UnityEngine.Animator"/> in its children (the same one).</item>
             <item>But <c>Characters</c> has two <see cref="T:UnityEngine.Animator"/>s in its children (one on each character).</item>
             </list>
             So it picks the <c>Character</c> as the root.
            
             <h2>Complex Hierarchy</h2>
             <code>    - Character - Rigidbody, etc.
                 - Model - Animator, AnimancerComponent
                 - States - Various components which reference the AnimationClips they will play
                 - Another Model - Animator (maybe the character is holding a gun which has a reload animation)</code>
             In this case, the automatic system would see that the <c>Character</c> already has more child
             <see cref="T:UnityEngine.Animator"/>s than the selected <c>Model</c> so it would only return the <c>Model</c> itself.
             This can be fixed by making any of the scripts on the <c>Character</c> implement <see cref="T:Animancer.ICharacterRoot"/>
             to tell the system which object you want it to use as the root.
             </example>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.Object)">
            <summary>
            Calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.GameObject)"/> if the specified `obj` is a <see cref="T:UnityEngine.GameObject"/> or
            <see cref="T:UnityEngine.Component"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AddContextMenuIK(UnityEditor.GenericMenu,Animancer.IHasIK)">
            <summary>Adds functions relevant to the `ik`.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerGUI">
            <summary>[Editor-Only] Various GUI utilities used throughout Animancer.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.WarningFieldColor">
            <summary>The highlight color used for fields showing a warning.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.ErrorFieldColor">
            <summary>The highlight color used for fields showing an error.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.DontExpandWidth">
            <summary><see cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)"/> set to false.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.LineHeight">
            <summary>Wrapper around <see cref="P:UnityEditor.EditorGUIUtility.singleLineHeight"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.StandardSpacing">
            <summary>Wrapper around <see cref="P:UnityEditor.EditorGUIUtility.standardVerticalSpacing"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.IndentSize">
            <summary>
            The number of pixels of indentation for each <see cref="P:UnityEditor.EditorGUI.indentLevel"/> increment.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.ToggleWidth">
            <summary>The width of a standard <see cref="P:UnityEngine.GUISkin.toggle"/> with no label.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.TextColor">
            <summary>The color of the standard label text.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.MiniButton">
            <summary>
            A more compact <see cref="P:UnityEditor.EditorStyles.miniButton"/> with a fixed size as a tiny box.
            </summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerGUI.SpacingMode">
            <summary>Indicates where <see cref="M:Animancer.Editor.AnimancerGUI.LayoutSingleLineRect(Animancer.Editor.AnimancerGUI.SpacingMode)"/> should add the <see cref="P:Animancer.Editor.AnimancerGUI.StandardSpacing"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.LayoutSingleLineRect(Animancer.Editor.AnimancerGUI.SpacingMode)">
            <summary>
            Uses <see cref="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single)"/> to get a <see cref="T:UnityEngine.Rect"/> occupying a single
            standard line with the <see cref="P:Animancer.Editor.AnimancerGUI.StandardSpacing"/> added according to the specified `spacing`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.NextVerticalArea(UnityEngine.Rect@)">
            <summary>
            If the <see cref="P:UnityEngine.Rect.height"/> is positive, this method moves the <see cref="P:UnityEngine.Rect.y"/> by that amount and
            adds the <see cref="P:UnityEditor.EditorGUIUtility.standardVerticalSpacing"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.StealFromLeft(UnityEngine.Rect@,System.Single,System.Single)">
            <summary>
            Subtracts the `width` from the left side of the `area` and returns a new <see cref="T:UnityEngine.Rect"/> occupying the
            removed section.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.StealFromRight(UnityEngine.Rect@,System.Single,System.Single)">
            <summary>
            Subtracts the `width` from the right side of the `area` and returns a new <see cref="T:UnityEngine.Rect"/> occupying the
            removed section.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.SplitHorizontally(UnityEngine.Rect,System.String,System.String,System.Single@,System.Single@,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>
            Divides the given `area` such that the fields associated with both labels will have equal space
            remaining after the labels themselves.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CalculateWidth(UnityEngine.GUIStyle,UnityEngine.GUIContent)">
            <summary>
            Calls <see cref="M:UnityEngine.GUIStyle.CalcMinMaxWidth(UnityEngine.GUIContent,System.Single@,System.Single@)"/> and returns the max width.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CalculateWidth(UnityEngine.GUIStyle,System.String)">
            <summary>
            Calls <see cref="M:UnityEngine.GUIStyle.CalcMinMaxWidth(UnityEngine.GUIContent,System.Single@,System.Single@)"/> and returns the max width.
            <para></para>
            This method uses the <see cref="M:Animancer.Editor.AnimancerGUI.TempContent(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CreateWidthCache(UnityEngine.GUIStyle)">
            <summary>
            Creates a <see cref="T:Animancer.Editor.ConversionCache`2"/> for calculating the GUI width occupied by text using the
            specified `style`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CalculateLabelWidth(System.String)">
            <summary>
            Calls <see cref="M:UnityEngine.GUIStyle.CalcMinMaxWidth(UnityEngine.GUIContent,System.Single@,System.Single@)"/> using <see cref="P:UnityEngine.GUISkin.label"/> and returns the max
            width. The result is cached for efficient reuse.
            <para></para>
            This method uses the <see cref="M:Animancer.Editor.AnimancerGUI.TempContent(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.BeginVerticalBox(UnityEngine.GUIStyle)">
            <summary>
            Begins a vertical layout group using the given style and decreases the
            <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> to compensate for the indentation.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.EndVerticalBox(UnityEngine.GUIStyle)">
            <summary>
            Ends a layout group started by <see cref="M:Animancer.Editor.AnimancerGUI.BeginVerticalBox(UnityEngine.GUIStyle)"/> and restores the
            <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI._TempContent">
            <summary>Used by <see cref="M:Animancer.Editor.AnimancerGUI.TempContent(System.String,System.String,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TempContent(System.String,System.String,System.Boolean)">
            <summary>
            Returns a <see cref="T:UnityEngine.GUIContent"/> with the specified parameters. The same instance is returned by
            every subsequent call.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TempContent(UnityEditor.SerializedProperty,System.Boolean)">
            <summary>
            Returns a <see cref="T:UnityEngine.GUIContent"/> with the <see cref="P:UnityEditor.SerializedProperty.displayName"/> and
            <see cref="P:UnityEditor.SerializedProperty.tooltip"/>. The same instance is returned by every subsequent call.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoWeightLabel(UnityEngine.Rect@,System.Single)">
            <summary>
            Draws a label showing the `weight` aligned to the right side of the `area` and reduces its
            <see cref="P:UnityEngine.Rect.width"/> to remove that label from its area.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI._TightLabelWidth">
            <summary>The <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> from before <see cref="M:Animancer.Editor.AnimancerGUI.BeginTightLabel(System.String)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.BeginTightLabel(System.String)">
            <summary>Stores the <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> and changes it to the exact width of the `label`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.EndTightLabel">
            <summary>Reverts <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> to its previous value.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.GetNarrowText(System.String)">
            <summary>
            Returns the `text` without any spaces if <see cref="P:UnityEditor.EditorGUIUtility.wideMode"/> is false.
            Otherwise simply returns the `text` without any changes.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TryUseClickEvent(UnityEngine.Rect,System.Int32)">
            <summary>
            Returns true and uses the current event if it is <see cref="F:UnityEngine.EventType.MouseUp"/> inside the specified
            `area`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TryUseClickEventInLastRect(System.Int32)">
            <summary>
            Returns true and uses the current event if it is <see cref="F:UnityEngine.EventType.MouseUp"/> inside the last GUI Layout
            <see cref="T:UnityEngine.Rect"/> that was drawn.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.HandleDragAndDrop``1(UnityEngine.Rect,System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Invokes `onDrop` if the <see cref="P:UnityEngine.Event.current"/> is a drag and drop event inside the `dropArea`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TryDrop``1(System.Collections.IEnumerable,System.Func{``0,System.Boolean},System.Action{``0},System.Boolean)">
            <summary>
            Updates the <see cref="P:UnityEditor.DragAndDrop.visualMode"/> of calls `onDrop` for each of the `objects`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.HandleDragAndDropAnimations(UnityEngine.Rect,System.Action{UnityEngine.AnimationClip})">
            <summary>
            Uses <see cref="M:Animancer.Editor.AnimancerGUI.HandleDragAndDrop``1(UnityEngine.Rect,System.Func{``0,System.Boolean},System.Action{``0})"/> to deal with drag and drop operations involving
            <see cref="T:UnityEngine.AnimationClip"/>s of <see cref="T:UnityEngine.IAnimationClipSource"/>s.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.Deselect">
            <summary>Deselects any selected IMGUI control.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoSpecialFloatField(UnityEngine.Rect,UnityEngine.GUIContent,System.Single,Animancer.Editor.ConversionCache{System.Single,System.String})">
            <summary>
            Draw a <see cref="M:UnityEditor.EditorGUI.FloatField(UnityEngine.Rect,UnityEngine.GUIContent,System.Single)"/> with an alternate cached string when it
            is not selected (for example, "1" might become "1s" to indicate "seconds").
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoFloatFieldWithSuffix(UnityEngine.Rect,UnityEngine.GUIContent,UnityEditor.SerializedProperty,Animancer.Editor.ConversionCache{System.Single,System.String})">
            <summary>
            Draw a <see cref="M:UnityEditor.EditorGUI.FloatField(UnityEngine.Rect,UnityEngine.GUIContent,System.Single)"/> with an alternate cached string when it
            is not selected (for example, "1" might become "1s" to indicate "seconds").
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoOptionalTimeField(UnityEngine.Rect@,UnityEngine.GUIContent,UnityEditor.SerializedProperty,System.Boolean,System.Single,System.Single,System.Boolean)">
            <summary>
            Draw a <see cref="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,UnityEngine.GUIContent)"/> which sets the value to <see cref="F:System.Single.NaN"/>
            when disabled followed by two float fields to display the <see cref="P:UnityEditor.SerializedProperty.floatValue"/> as
            both normalized time and seconds.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoOptionalTimeField(UnityEngine.Rect@,UnityEngine.GUIContent,System.Single,System.Boolean,System.Single,System.Single,System.Boolean)">
            <summary>
            Draw a <see cref="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,UnityEngine.GUIContent)"/> which sets the value to <see cref="F:System.Single.NaN"/>
            when disabled followed by two float fields to display the `time` both normalized and in seconds.
            </summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerSettings">
            <summary>[Editor-Only] Persistent settings used by Animancer.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerSettings.SerializedObject">
            <summary>The <see cref="T:UnityEditor.SerializedProperty"/> representing the <see cref="P:Animancer.Editor.AnimancerSettings.Instance"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerSettings.Group">
            <summary>Base class for groups of fields that can be serialized inside <see cref="T:Animancer.Editor.AnimancerSettings"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerSettings.Group.SetBasePropertyPath``1(``0@,System.String)">
            <summary>[Internal] Sets the prefix for <see cref="M:Animancer.Editor.AnimancerSettings.Group.GetSerializedProperty(System.String)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerSettings.SetDirty">
            <summary>Calls <see cref="M:UnityEditor.EditorUtility.SetDirty(UnityEngine.Object)"/> on the <see cref="P:Animancer.Editor.AnimancerSettings.Instance"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerSettings.TransitionPreviewWindow">
            <summary>Settings for the <see cref="P:Animancer.Editor.AnimancerSettings.TransitionPreviewWindow"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerSettings.InspectorRepaintInterval">
            <summary>
            The amount of time between repaint commands when
            <see cref="F:Animancer.Editor.AnimancerPlayableDrawer.RepaintConstantly"/> is disabled.
            </summary>
        </member>
        <member name="T:Animancer.Editor.AnimationType">
            <summary>[Editor-Only] The general type of object an <see cref="T:UnityEngine.AnimationClip"/> can animate.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.None">
            <summary>Unable to determine a type.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.Humanoid">
            <summary>A Humanoid rig.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.Generic">
            <summary>A Generic rig.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.Sprite">
            <summary>A <see cref="F:Animancer.Editor.AnimationType.Generic"/> rig which only animates a <see cref="P:UnityEngine.SpriteRenderer.sprite"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimationBindings">
            <summary>[Editor-Only]
            Various utility functions relating to the properties animated by an <see cref="T:UnityEngine.AnimationClip"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetAnimationType(UnityEngine.AnimationClip)">
            <summary>Determines the <see cref="T:Animancer.Editor.AnimationType"/> of the specified `clip`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetAnimationType(UnityEngine.Animator)">
            <summary>Determines the <see cref="T:Animancer.Editor.AnimationType"/> of the specified `animator`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetAnimationType(UnityEngine.GameObject)">
            <summary>Determines the <see cref="T:Animancer.Editor.AnimationType"/> of the specified `gameObject`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetBindings(UnityEngine.GameObject)">
            <summary>Returns a cached <see cref="T:Animancer.Editor.AnimationBindings.BindingData"/> representing the specified `gameObject`.</summary>
            <remarks>Note that the cache is cleared by <see cref="E:UnityEditor.EditorApplication.hierarchyChanged"/>.</remarks>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetBindings(UnityEngine.AnimationClip)">
            <summary>Returns a cached array of all properties animated by the specified `clip`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.OnAnimationChanged(UnityEngine.AnimationClip)">
            <summary>Clears any cached values relating to the `clip` since they may no longer be correct.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.ClearCache">
            <summary>Clears all cached values in this class.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimationBindings.BindingData">
            <summary>
            A collection of data about the properties on a <see cref="T:UnityEngine.GameObject"/> and its children
            which can be animated and the relationships between those properties and the properties that individual
            <see cref="T:UnityEngine.AnimationClip"/>s are trying to animate.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.BindingData.GameObject">
            <summary>The target object that this data represents.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.BindingData.#ctor(UnityEngine.GameObject)">
            <summary>Creates a new <see cref="T:Animancer.Editor.AnimationBindings.BindingData"/> representing the specified `gameObject`.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimationBindings.BindingData.ObjectType">
            <summary>The cached <see cref="T:Animancer.Editor.AnimationType"/> of the <see cref="F:Animancer.Editor.AnimationBindings.BindingData.GameObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimationBindings.BindingData.ObjectBindings">
            <summary>The cached properties of the <see cref="F:Animancer.Editor.AnimationBindings.BindingData.GameObject"/> and its children which can be animated.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.BindingData.GetMatchType(Animancer.AnimancerState,System.Text.StringBuilder)">
            <summary>
            Determines the <see cref="T:Animancer.Editor.AnimationBindings.MatchType"/> representing the properties animated by the `state` in
            comparison to the properties that actually exist on the target <see cref="F:Animancer.Editor.AnimationBindings.BindingData.GameObject"/> and its
            children.
            <para></para>
            Also compiles a `message` explaining the differences if that paraneter is not null.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.BindingData.GetMatchType(UnityEngine.AnimationClip,System.Text.StringBuilder,System.Collections.Generic.Dictionary{UnityEditor.EditorCurveBinding,System.Boolean},System.Int32@)">
            <summary>
            Determines the <see cref="T:Animancer.Editor.AnimationBindings.MatchType"/> representing the properties animated by the `clip` in
            comparison to the properties that actually exist on the target <see cref="F:Animancer.Editor.AnimationBindings.BindingData.GameObject"/> and its
            children.
            <para></para>
            Also compiles a `message` explaining the differences if that paraneter is not null.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.BindingData.LogIssues(Animancer.AnimancerState,Animancer.Editor.AnimationBindings.MatchType)">
            <summary>
            Logs a description of the issues found when comparing the properties animated by the `state` to the
            properties that actually exist on the target <see cref="F:Animancer.Editor.AnimationBindings.BindingData.GameObject"/> and its children.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.BindingData.OnAnimationChanged(UnityEngine.AnimationClip)">
            <summary>[Internal] Removes any cached values relating to the `clip`.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimationBindings.MatchType">
            <summary>
            A summary of the compatability between the properties animated by an <see cref="T:UnityEngine.AnimationClip"/> and the
            properties that actually exist on a particular <see cref="T:UnityEngine.GameObject"/> (and its children).
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.MatchType.Correct">
            <summary>All properties exist.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.MatchType.Empty">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> does not animate anything.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.MatchType.Warning">
            <summary>Some of the animated properties do not exist on the object.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.MatchType.Error">
            <summary>None of the animated properties exist on the object.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.DoBindingMatchGUI(UnityEngine.Rect@,Animancer.AnimancerState)">
            <summary>
            Draws a <see cref="M:UnityEngine.GUI.Button(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle)"/> indicating the <see cref="T:Animancer.Editor.AnimationBindings.MatchType"/> of the
            `state` compared to the object it is being played on.
            <para></para>
            Clicking the button calls <see cref="M:Animancer.Editor.AnimationBindings.BindingData.LogIssues(Animancer.AnimancerState,Animancer.Editor.AnimationBindings.MatchType)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.AssertIcons">
            <summary>A unit test to make sure that the icons are properly loaded.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimationGatherer">
            <summary>[Editor-Only]
            Allows animations to be procedurally gathered throughout the hierarchy without needing explicit references.
            </summary>
            <remarks>
            This class is [Editor-Only] because it uses reflection and is not particularly efficient, but it does not
            actually use any Editor Only functionality so it could be made usable at runtime by simply removing the
            <c>#if UNITY_EDITOR</c> at the top of the file and <c>#endif</c> at the bottom.
            </remarks>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.ClearCache">
            <summary>Clears all cached animations.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimationGatherer.ExceptionHandler">
            <summary>An action that can be performed in response to an exception.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationGatherer.ExceptionHandler.Store">
            <summary>
            Store the exception in a list so it can be displayed in the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/> if
            the user wants to debug it. This is the default because some systems are not prepared to have their
            members accessed via reflection and we don't want to bother the user with non-critical errors.
            </summary>
            <remarks>Only</remarks>
        </member>
        <member name="F:Animancer.Editor.AnimationGatherer.ExceptionHandler.Log">
            <summary>Log the exception normally.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimationGatherer.Exceptions">
            <summary>
            The exceptions that have been stored according to the <see cref="P:Animancer.Editor.AnimationGatherer.ExceptionCapacity"/>.
            This property is null if no exceptions have been thrown yet.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimationGatherer.ExceptionCapacity">
            <summary>
            A positive value causes exceptions thrown while gathering animations to be stores in a list so they can be
            displayed in the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/> if the user wants to debug them rather than logging
            them immediately.
            <para></para>
            0 causes exceptions to be ignored entirely and any negative value causes them to be logged immediately.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromGameObject(UnityEngine.GameObject,System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>
            Fills the `clips` with any <see cref="T:UnityEngine.AnimationClip"/>s referenced by components in the same hierarchy as
            the `gameObject`. See <see cref="T:Animancer.ICharacterRoot"/> for details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromGameObject(UnityEngine.GameObject,UnityEngine.AnimationClip[]@,System.Boolean)">
            <summary>
            Fills the `clips` with any <see cref="T:UnityEngine.AnimationClip"/>s referenced by components in the same hierarchy as
            the `gameObject`. See <see cref="T:Animancer.ICharacterRoot"/> for details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromObject(System.Object,System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Int32)">
            <summary>
            Gathers all animations from the `source`s fields.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimationGatherer.TypeToGatherer">
            <summary>Types mapped to a delegate that can quickly gather their clips.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromFields(System.Object,System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Int32)">
            <summary>
            Uses reflection to gather <see cref="T:UnityEngine.AnimationClip"/>s from fields on the `source` object.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.BuildClipGatherer(System.Type,System.Int32)">
            <summary>
            Creates a delegate to gather <see cref="T:UnityEngine.AnimationClip"/>s from all relevant fields in a given `type`.
            </summary>
        </member>
        <member name="T:Animancer.Editor.BoolPref">
            <summary>[Editor-Only]
            A simple wrapper around <see cref="T:UnityEditor.EditorPrefs"/> to get and set a bool.
            <para></para>
            If you are interested in a more comprehensive pref wrapper that supports more types, you should check out
            <see href="https://kybernetik.com.au/inspector-gadgets">Inspector Gadgets</see>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.KeyPrefix">
            <summary>The prefix which is automatically added before the <see cref="F:Animancer.Editor.BoolPref.Key"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.Key">
            <summary>The identifier with which this pref will be saved.</summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.MenuItem">
            <summary>The label to use when adding a function to toggle this pref to a menu.</summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.DefaultValue">
            <summary>The starting value to use for this pref if none was previously saved.</summary>
        </member>
        <member name="P:Animancer.Editor.BoolPref.Value">
            <summary>The current value of this pref.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.op_Implicit(Animancer.Editor.BoolPref)~System.Boolean">
            <summary>Returns the current value of the `pref`.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.#ctor(System.String,System.Boolean)">
            <summary>Constructs a new <see cref="T:Animancer.Editor.BoolPref"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.#ctor(System.String,System.String,System.Boolean)">
            <summary>Constructs a new <see cref="T:Animancer.Editor.BoolPref"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.AddToggleFunction(UnityEditor.GenericMenu)">
            <summary>
            Adds a menu function to toggle the <see cref="P:Animancer.Editor.BoolPref.Value"/> of this pref.
            </summary>
        </member>
        <member name="T:Animancer.Editor.ConversionCache`2">
            <summary>
            A simple system for converting objects and storing the results so they can be reused to minimise the need for
            garbage collection, particularly for string construction.
            </summary>
        </member>
        <member name="M:Animancer.Editor.ConversionCache`2.#ctor(System.Func{`0,`1})">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.ConversionCache`2"/> which uses the specified delegate to convert values.
            </summary>
        </member>
        <member name="M:Animancer.Editor.ConversionCache`2.Convert(`0)">
            <summary>
            If a value has already been cached for the specified `key`, return it. Otherwise create a new one using
            the delegate provided in the constructor and cache it.
            <para></para>
            This method also periodically removes values that have not been used recently.
            </summary>
        </member>
        <member name="T:Animancer.Editor.GUIElementWidth">
            <summary>[Editor-Only] A cached width calculation for GUI elements.</summary>
        </member>
        <member name="M:Animancer.Editor.GUIElementWidth.GetWidth(UnityEngine.GUIStyle,System.String)">
            <summary>Returns the width the `text` would take up if drawn with the `style`.</summary>
        </member>
        <member name="M:Animancer.Editor.GUIElementWidth.OnRecalculate(UnityEngine.GUIStyle,System.String)">
            <summary>Called when <see cref="M:Animancer.Editor.GUIElementWidth.GetWidth(UnityEngine.GUIStyle,System.String)"/> is called with different parameters.</summary>
        </member>
        <member name="T:Animancer.Editor.GUIElementWidthBoldable">
            <summary>[Editor-Only]
            A cached width calculation for GUI elements which accounts for boldness in prefab overrides.
            </summary>
        </member>
        <member name="M:Animancer.Editor.GUIElementWidthBoldable.OnRecalculate(UnityEngine.GUIStyle,System.String)">
            <summary>Called when <see cref="M:Animancer.Editor.GUIElementWidth.GetWidth(UnityEngine.GUIStyle,System.String)"/> is called with different parameters.</summary>
        </member>
        <member name="M:Animancer.Editor.GUIElementWidthBoldable.GetWidth(UnityEngine.GUIStyle,System.String,System.Boolean)">
            <summary>Returns the width the `text` would take up if drawn with the `style`.</summary>
        </member>
        <member name="M:Animancer.Editor.GUIElementWidthBoldable.GetWidth(UnityEngine.GUIStyle,System.String,UnityEditor.SerializedProperty)">
            <summary>Returns the width the `text` would take up if drawn with the `style`.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerLayerDrawer">
            <summary>[Internal]
            A custom Inspector for an <see cref="T:Animancer.AnimancerLayer"/> which sorts and exposes some of its internal values.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.ActiveStates">
            <summary>The states in the target layer which have non-zero <see cref="P:Animancer.AnimancerNode.Weight"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.InactiveStates">
            <summary>The states in the target layer which have zero <see cref="P:Animancer.AnimancerNode.Weight"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerLayerDrawer.RegionStyle">
            <summary>The <see cref="T:UnityEngine.GUIStyle"/> used for the area encompassing this drawer. <see cref="P:UnityEngine.GUISkin.box"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.GatherLayerEditors(Animancer.AnimancerPlayable,System.Collections.Generic.List{Animancer.Editor.AnimancerLayerDrawer},System.Int32@)">
            <summary>
            Initialises an editor in the list for each layer in the `animancer`.
            <para></para>
            The `count` indicates the number of elements actually being used. Spare elements are kept in the list in
            case they need to be used again later.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.GatherStates(Animancer.AnimancerLayer)">
            <summary>
            Sets the target `layer` and sorts its states and their keys into the active/inactive lists.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.SortAndGatherKeys(System.Collections.Generic.List{Animancer.AnimancerState})">
            <summary>
            Sorts any entries that use another state as their key to come right after that state.
            See <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoLabelGUI(UnityEngine.Rect)">
            <summary>
            Draws the layer's name and weight.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.FoldoutIndent">
            <summary>The number of pixels of indentation required to fit the foldout arrow.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoFoldoutGUI(UnityEngine.Rect)">
            <summary>Draws a foldout arrow to expand/collapse the state details.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoDetailsGUI">
            <summary> Draws the details of the target state in the GUI.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoLayerDetailsGUI">
            <summary>
            Draws controls for <see cref="P:Animancer.AnimancerLayer.IsAdditive"/> and <see cref="F:Animancer.AnimancerLayer._Mask"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoStatesGUI(System.String,System.Collections.Generic.List{Animancer.AnimancerState})">
            <summary>Draws all `states` in the given list.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.StateInspectors">
            <summary>Cached Inspectors that have already been created for states.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoStateGUI(Animancer.AnimancerState)">
            <summary>Draws the Inspector for the given `state`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoChildStatesGUI(Animancer.AnimancerState)">
            <summary>Draws all child states of the `state`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoGUI">
            <summary>
            Draws the details and controls for the target <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the Inspector.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.HandleDragAndDropAnimations(UnityEngine.Rect,Animancer.IAnimancerComponent,System.Int32)">
            <summary>
            If <see cref="T:UnityEngine.AnimationClip"/>s or <see cref="T:UnityEngine.IAnimationClipSource"/>s are dropped inside the `dropArea`,
            this method creates a new state in the `target` for each animation.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.PopulateContextMenu(UnityEditor.GenericMenu)">
            <summary>Adds functions relevant to the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.IAnimancerNodeDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerNode"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.IAnimancerNodeDrawer.DoGUI">
            <summary>Draws the details and controls for the target node in the Inspector.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerNodeDrawer`1">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerNode"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerNodeDrawer`1.Target">
            <summary>The node being managed.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerNodeDrawer`1.IsExpanded">
            <summary>If true, the details of the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> will be expanded in the Inspector.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerNodeDrawer`1.RegionStyle">
            <summary>The <see cref="T:UnityEngine.GUIStyle"/> used for the area encompassing this drawer.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoGUI">
            <summary>Draws the details and controls for the target <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the Inspector.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoHeaderGUI">
            <summary>
            Draws the name and other details of the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the GUI.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoLabelGUI(UnityEngine.Rect)">
            <summary>
            Draws a field for the <see cref="P:Animancer.AnimancerState.MainObject"/> if it has one, otherwise just a simple text
            label.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoFoldoutGUI(UnityEngine.Rect)">
            <summary>Draws a foldout arrow to expand/collapse the node details.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoDetailsGUI">
            <summary>Draws the details of the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the GUI.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoNodeDetailsGUI">
            <summary>
            Draws controls for <see cref="P:Animancer.AnimancerState.IsPlaying"/>, <see cref="P:Animancer.AnimancerNode.Speed"/>, and
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoFadeDetailsGUI">
            <summary>
            Draws controls for <see cref="P:Animancer.AnimancerNode.FadeSpeed"/> and <see cref="P:Animancer.AnimancerNode.TargetWeight"/>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerNodeDrawer`1.DetailsPrefix">
            <summary>
            The menu label prefix used for details about the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.CheckContextMenu(UnityEngine.Rect)">
            <summary>
            Checks if the current event is a context menu click within the `clickArea` and opens a context menu with various
            functions for the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.PopulateContextMenu(UnityEditor.GenericMenu)">
            <summary>Adds functions relevant to the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerPlayableDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="P:Animancer.IAnimancerComponent.Playable"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerPlayableDrawer.LayerInfos">
            <summary>A lazy list of information about the layers currently being displayed.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerPlayableDrawer._LayerCount">
            <summary>The number of elements in <see cref="F:Animancer.Editor.AnimancerPlayableDrawer.LayerInfos"/> that are currently being used.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.DoGUI(Animancer.IAnimancerComponent[])">
            <summary>Draws the GUI of the <see cref="P:Animancer.IAnimancerComponent.Playable"/> if there is only one target.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.DoGUI(Animancer.IAnimancerComponent)">
            <summary>Draws the GUI of the <see cref="P:Animancer.IAnimancerComponent.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.DoInternalDetailsGUI(Animancer.AnimancerPlayable)">
            <summary>Draws a box describing the internal details of the `playable`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.CheckContextMenu(UnityEngine.Rect,Animancer.AnimancerPlayable)">
            <summary>
            Checks if the current event is a context menu click within the `clickArea` and opens a context menu with various
            functions for the `playable`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.AddRootFunctions(UnityEditor.GenericMenu,Animancer.AnimancerPlayable)">
            <summary>Adds functions for controlling the `playable`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.AddUpdateModeFunctions(UnityEditor.GenericMenu,Animancer.AnimancerPlayable)">
            <summary>Adds menu functions to set the <see cref="T:UnityEngine.Playables.DirectorUpdateMode"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.AddDisposablesFunctions(UnityEditor.GenericMenu,System.Collections.Generic.List{System.IDisposable})">
            <summary>Adds disabled items for each disposable.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.AddPlayableGraphVisualizerFunction(UnityEditor.GenericMenu,System.String,UnityEngine.Playables.PlayableGraph)">
            <summary>Adds a menu function to open the Playable Graph Visualiser if it exists in the project.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.AddDisplayOptions(UnityEditor.GenericMenu)">
            <summary>Adds functions to the menu for each of the Display Options.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerStateDrawer`1">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.#ctor(`0)">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.AnimancerStateDrawer`1"/> to manage the Inspector GUI for the `target`.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerStateDrawer`1.RegionStyle">
            <summary>The <see cref="T:UnityEngine.GUIStyle"/> used for the area encompassing this drawer. Null.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerStateDrawer`1.IsAssetUsedAsKey">
            <summary>Determines whether the <see cref="P:Animancer.AnimancerState.MainObject"/> field can occupy the whole line.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoLabelGUI(UnityEngine.Rect)">
            <summary>
            Draws the state's main label: an <see cref="T:UnityEngine.Object"/> field if it has a
            <see cref="P:Animancer.AnimancerState.MainObject"/>, otherwise just a simple text label.
            <para></para>
            Also shows a bar to indicate its progress.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.HandleLabelClick(UnityEngine.Rect)">
            <summary>
            Handles Ctrl + Click on the label to CrossFade the animation.
            <para></para>
            If Shift is also held, the effect will be queued until after the previous animation finishes.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoFoldoutGUI(UnityEngine.Rect)">
            <summary>Draws a foldout arrow to expand/collapse the state details.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerStateDrawer`1.AnimationQueue">
            <summary>
            Manages the playing of animations in sequence.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.AnimationQueue.CleanUp">
            <summary>
            Clear out any playables that have been destroyed.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.GetWrappedTime(System.Single@)">
            <summary>
            Gets the current <see cref="P:Animancer.AnimancerState.Time"/>.
            If the state is looping, the value is modulo by the <see cref="P:Animancer.AnimancerState.Length"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoDetailsGUI">
            <summary> Draws the details of the target state in the GUI.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoTimeSliderGUI">
            <summary>Draws a slider for controlling the current <see cref="P:Animancer.AnimancerState.Time"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.PopulateContextMenu(UnityEditor.GenericMenu)">
            <summary>Adds functions relevant to the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.AddContextMenuFunctions(UnityEditor.GenericMenu)">
            <summary>Adds the details of this state to the `menu`.</summary>
        </member>
        <member name="T:Animancer.Editor.BaseAnimancerComponentEditor">
            <summary>[Editor-Only]
            A custom Inspector for <see cref="T:Animancer.IAnimancerComponent"/>s.
            </summary>
        </member>
        <member name="P:Animancer.Editor.BaseAnimancerComponentEditor.Targets">
            <summary><see cref="P:UnityEditor.Editor.targets"/> casted to <see cref="T:Animancer.IAnimancerComponent"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.BaseAnimancerComponentEditor._AnimatorEditor">
            <summary>The serialized backing field for the target's <see cref="T:UnityEngine.Animator"/> reference.</summary>
        </member>
        <member name="F:Animancer.Editor.BaseAnimancerComponentEditor.PlayableDrawer">
            <summary>The drawer for the <see cref="P:Animancer.IAnimancerComponent.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.OnEnable">
            <summary>Initialises this <see cref="T:UnityEditor.Editor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.GatherTargets">
            <summary>
            Copies the <see cref="P:UnityEditor.Editor.targets"/> into the <see cref="F:Animancer.Editor.BaseAnimancerComponentEditor._Targets"/> array.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.OnDisable">
            <summary>
            Cleans up this <see cref="T:UnityEditor.Editor"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.OnInspectorGUI">
            <summary>
            Called by the Unity editor to draw the custom Inspector GUI elements.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.RequiresConstantRepaint">
            <summary>
            If we have only one object selected and are in Play Mode, we need to constantly repaint to keep the
            Inspector up to date with the latest details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.DoOtherFieldsGUI">
            <summary>Draws the rest of the Inspector fields after the Animator field.</summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.DoOverridePropertyGUI(System.String,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>[Editor-Only]
            Draws any custom GUI for the `property`.
            The return value indicates whether the GUI should replace the regular call to
            <see cref="M:UnityEditor.EditorGUILayout.PropertyField(UnityEditor.SerializedProperty,UnityEngine.GUIContent,System.Boolean,UnityEngine.GUILayoutOption[])"/> or
            not. True = GUI was drawn, so don't draw the regular GUI. False = Draw the regular GUI.
            </summary>
        </member>
        <member name="T:Animancer.Editor.DummySerializableCallback">
            <summary>
            An object that holds a serialized callback (a <see cref="T:UnityEngine.Events.UnityEvent"/> by default) so that empty ones can be
            drawn in the GUI without allocating array space for them until they actually contain something.
            </summary>
        </member>
        <member name="T:Animancer.Editor.EventSequenceDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.EventSequenceDrawer.Context">
            <summary>Details of an <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.EventSequenceDrawer.Context.SerializedArrayProperty">
            <summary>A wrapper around a <see cref="T:UnityEditor.SerializedProperty"/> representing an array field.</summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.SerializedArrayProperty.Property">
            <summary>The property representing the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable._NormalizedTimes"/> field.</summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.SerializedArrayProperty.Count">
            <summary>The cached <see cref="P:UnityEditor.SerializedProperty.arraySize"/> of <see cref="P:Animancer.Editor.EventSequenceDrawer.Context.SerializedArrayProperty.Property"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Context.SerializedArrayProperty.RefreshCount">
            <summary>Updates the cached <see cref="P:Animancer.Editor.EventSequenceDrawer.Context.SerializedArrayProperty.Count"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Context.SerializedArrayProperty.GetElement(System.Int32)">
            <summary>Shorthand for <see cref="M:UnityEditor.SerializedProperty.GetArrayElementAtIndex(System.Int32)"/> on <see cref="P:Animancer.Editor.EventSequenceDrawer.Context.SerializedArrayProperty.Property"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.Property">
            <summary>The main property representing the <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/> field.</summary>
        </member>
        <member name="F:Animancer.Editor.EventSequenceDrawer.Context.Times">
            <summary>The property representing the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable._NormalizedTimes"/> field.</summary>
        </member>
        <member name="F:Animancer.Editor.EventSequenceDrawer.Context.Names">
            <summary>The property representing the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable._Names"/> field.</summary>
        </member>
        <member name="F:Animancer.Editor.EventSequenceDrawer.Context.Callbacks">
            <summary>The property representing the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable._Callbacks"/> field.</summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.SelectedEvent">
            <summary>The index of the currently selected event.</summary>
        </member>
        <member name="F:Animancer.Editor.EventSequenceDrawer.Context.Instance">
            <summary>The singleton instance.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Context.Get(UnityEditor.SerializedProperty)">
            <summary>
            Returns a <see cref="T:Animancer.Editor.EventSequenceDrawer.Context"/> representing the `property`.
            <para></para>
            Note that the same instance is returned every time.
            </summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Context.Dispose">
            <summary>[<see cref="T:System.IDisposable"/>]
            Reduces the <see cref="F:Animancer.Editor.EventSequenceDrawer.Context.Callbacks"/> array size to remove any empty elements.
            </summary>
        </member>
        <member name="P:Animancer.Editor.EventSequenceDrawer.Context.TransitionContext">
            <summary>Shorthand for <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.CanCacheInspectorGUI(UnityEditor.SerializedProperty)">
            <summary>Can't cache because the <see cref="F:Animancer.Editor.EventSequenceDrawer.TimeRuler"/> doesn't work properly.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Calculates the number of vertical pixels the `property` will occupy when it is drawn.
            </summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>Draws the GUI for the `property`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.DoAddEventButtonGUI(UnityEngine.Rect,Animancer.Editor.EventSequenceDrawer.Context)">
            <summary>Draws a button to add a new event.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.DoEventGUI(UnityEngine.Rect@,Animancer.Editor.EventSequenceDrawer.Context,System.Int32,System.Boolean,System.Boolean)">
            <summary>Draws the GUI fields for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.DoNameGUI(UnityEngine.Rect@,Animancer.Editor.EventSequenceDrawer.Context,System.Int32,System.String)">
            <summary>Draws the time field for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.DoTimeGUI(UnityEngine.Rect@,Animancer.Editor.EventSequenceDrawer.Context,System.Int32,System.Boolean,System.String,System.Single,System.Boolean)">
            <summary>Draws the time field for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.DoTimeGUI(UnityEngine.Rect@,Animancer.Editor.EventSequenceDrawer.Context,System.Int32,System.Boolean)">
            <summary>Draws the time field for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.DoCallbackGUI(UnityEngine.Rect@,Animancer.Editor.EventSequenceDrawer.Context,System.Int32,System.Boolean,System.String)">
            <summary>Draws the GUI fields for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.RemoveEvent(Animancer.Editor.EventSequenceDrawer.Context,System.Int32)">
            <summary>Removes the event at the specified `index`.</summary>
        </member>
        <member name="T:Animancer.Editor.NestedAnimatorEditor">
            <summary>[Editor-Only]
            A custom Inspector for drawing the <see cref="P:Animancer.IAnimancerComponent.Animator"/> nested inside its own Inspector.
            </summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor.Targets">
            <summary>The <see cref="T:Animancer.IAnimancerComponent"/> objects being edited.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor.AnimatorProperty">
            <summary>The property that serializes the <see cref="P:Animancer.IAnimancerComponent.Animator"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._Animators">
            <summary>The animator referenced by each target.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._IsAnimatorOnSameObject">
            <summary>
            Indicates whether all <see cref="F:Animancer.Editor.NestedAnimatorEditor._Animators"/> are on the same <see cref="T:UnityEngine.GameObject"/> as the target that
            is referencing them.
            </summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator">
            <summary>A <see cref="T:UnityEditor.SerializedObject"/> encapsulating the <see cref="F:Animancer.Editor.NestedAnimatorEditor._Animators"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._Controller">
            <summary>A <see cref="T:UnityEditor.SerializedProperty"/> of the <see cref="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._Avatar">
            <summary>A <see cref="T:UnityEditor.SerializedProperty"/> of the <see cref="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._RootMotion">
            <summary>A <see cref="T:UnityEditor.SerializedProperty"/> of the <see cref="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._UpdateMode">
            <summary>A <see cref="T:UnityEditor.SerializedProperty"/> of the <see cref="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.NestedAnimatorEditor._CullingMode">
            <summary>A <see cref="T:UnityEditor.SerializedProperty"/> of the <see cref="F:Animancer.Editor.NestedAnimatorEditor._SerializedAnimator"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.#ctor(Animancer.IAnimancerComponent[],UnityEditor.SerializedProperty)">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.NestedAnimatorEditor"/> to wrap the `animatorProperty`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.Destroy">
            <summary>
            Cleans up this editor.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.GatherAnimatorProperties">
            <summary>
            Ensures that the <see cref="T:UnityEditor.SerializedObject"/> and properties for the <see cref="F:Animancer.Editor.NestedAnimatorEditor._Animators"/> have been
            initialised.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.GatherAnimators">
            <summary>Gathers the <see cref="F:Animancer.Editor.NestedAnimatorEditor._Animators"/> from the <see cref="F:Animancer.Editor.NestedAnimatorEditor.Targets"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.DoInspectorGUI">
            <summary>
            Draws the animator reference field followed by its fields that are relevant to Animancer.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.DoControllerGUI">
            <summary>
            Draws the <see cref="P:UnityEngine.Animator.runtimeAnimatorController"/> field with a warning if a controller is
            assigned.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.DoUpdateModeGUI(System.Boolean)">
            <summary>
            Draws the <see cref="P:UnityEngine.Animator.updateMode"/> field with any appropriate warnings.
            </summary>
        </member>
        <member name="M:Animancer.Editor.NestedAnimatorEditor.DoCullingModeGUI">
            <summary>
            Draws the <see cref="P:UnityEngine.Animator.cullingMode"/> field.
            </summary>
        </member>
        <member name="T:Animancer.Editor.ParametizedAnimancerStateDrawer`1">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.ParametizedAnimancerStateDrawer`1.ParameterCount">
            <summary>The number of parameters being managed by the target state.</summary>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.#ctor(`0)">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.ParametizedAnimancerStateDrawer`1"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.DoDetailsGUI">
            <summary>Draws the details of the target state in the GUI.</summary>
        </member>
        <member name="T:Animancer.Editor.TimeRuler">
            <summary>[Editor-Only] Draws a GUI box denoting a period of time.</summary>
        </member>
        <member name="P:Animancer.Editor.TimeRuler.EventIcon">
            <summary>The icon used for events.</summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.SecondsToPixels(System.Single)">
            <summary>Converts a number of seconds to a horizontal pixel position along the ruler.</summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.PixelsToSeconds(System.Single)">
            <summary>Converts a horizontal pixel position along the ruler to a number of seconds.</summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.SecondsToNormalized(System.Single)">
            <summary>Converts a number of seconds to a normalized time value.</summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.NormalizedToSeconds(System.Single)">
            <summary>Converts a normalized time value to a number of seconds.</summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.BeginGUI(UnityEngine.Rect)">
            <summary>
            Sets the `area` in which the ruler will be drawn and draws a <see cref="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)"/> there.
            Must be followed by a call to <see cref="M:Animancer.Editor.TimeRuler.EndGUI"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.EndGUI">
            <summary>
            Uses any unused <see cref="F:UnityEngine.EventType.MouseDown"/> events in the area and ends the area started by
            <see cref="M:Animancer.Editor.TimeRuler.BeginGUI(UnityEngine.Rect)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.DoGUI(UnityEngine.Rect,Animancer.Editor.EventSequenceDrawer.Context,System.Single@)">
            <summary>
            Draws the ruler GUI and handles input events for the specified `context`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.GetFadeOutEnd(System.Single,System.Single,System.Single)">
            <summary>Calculates the end time of the fade out.</summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.DoFadeHighlightGUI">
            <summary>
            Draws a polygon describing the start, end, and fade details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.DoEventsGUI(Animancer.Editor.EventSequenceDrawer.Context,System.Single@)">
            <summary>
            Draws the details of the <see cref="F:Animancer.Editor.EventSequenceDrawer.Context.Callbacks"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimeRuler.DoRulerGUI">
            <summary>
            Draws ticks and labels for important times throughout the area.
            </summary>
        </member>
        <member name="T:Animancer.Editor.TransitionDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.AnimancerState.Transition`1"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionDrawer.Mode">
            <summary>The visual state of a drawer.</summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer._Mode">
            <summary>The current state of this drawer.</summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer.MainPropertyName">
            <summary>
            If set, the field with this name will be drawn with the foldout arrow instead of in its default place.
            </summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer.MainPropertyPathSuffix">
            <summary>
            "." + <see cref="F:Animancer.Editor.TransitionDrawer.MainPropertyName"/> (to avoid creating garbage repeatedly).
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.Editor.TransitionDrawer"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.#ctor(System.String)">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.TransitionDrawer"/> and sets the
            <see cref="F:Animancer.Editor.TransitionDrawer.MainPropertyName"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.GetMainProperty(UnityEditor.SerializedProperty)">
            <summary>
            Returns the property specified by the <see cref="F:Animancer.Editor.TransitionDrawer.MainPropertyName"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Calculates the number of vertical pixels the `property` will occupy when it is drawn.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Draws the root `property` GUI and calls <see cref="M:Animancer.Editor.TransitionDrawer.DoPropertyGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> for each of its children.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.InitialiseMode(UnityEditor.SerializedProperty)">
            <summary>
            If the <see cref="F:Animancer.Editor.TransitionDrawer._Mode"/> is <see cref="F:Animancer.Editor.TransitionDrawer.Mode.Uninitialised"/>, this method determines how it should start
            based on the number of properties in the `serializedObject`. If the only serialized field is an
            <see cref="T:Animancer.AnimancerState.Transition`1"/> then it should start expanded.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.DoPropertyGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Draws the `property` GUI in relation to the `rootProperty` which was passed into <see cref="M:Animancer.Editor.TransitionDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer.NormalizedStartTimeFieldName">
            <summary>The name of the backing field of <see cref="P:Animancer.ClipState.Transition.NormalizedStartTime"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.TryDoStartTimeField(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            If the `property` is a "Start Time" field, this method draws it as well as the "End Time" below it and
            returns true.
            </summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.Context">
            <summary>The current <see cref="T:Animancer.Editor.TransitionDrawer.TransitionContext"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionDrawer.TransitionContext">
            <summary>Details of an <see cref="T:Animancer.AnimancerState.Transition`1"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.TransitionContext.Property">
            <summary>The main property representing the <see cref="T:Animancer.AnimancerState.Transition`1"/> field.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.TransitionContext.Transition">
            <summary>The actual transition object rerieved from the <see cref="P:Animancer.Editor.TransitionDrawer.TransitionContext.Property"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.TransitionContext.MaximumDuration">
            <summary>The cached value of <see cref="P:Animancer.ITransitionDetailed.MaximumDuration"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.TransitionContext.Get(Animancer.Editor.TransitionDrawer,UnityEditor.SerializedProperty)">
            <summary>
            Returns a disposable <see cref="T:Animancer.Editor.TransitionDrawer.TransitionContext"/> representing the specified parameters.
            <para></para>
            Note that the same instance is returned every time and it can be accessed via <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.TransitionContext.Dispose">
            <summary>Clears the <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.MenuFunctionState">
            <summary>The possible states for a function in a <see cref="T:UnityEditor.GenericMenu"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.MenuFunctionState.Normal">
            <summary>Displayed normally.</summary>
        </member>
        <member name="F:Animancer.Editor.MenuFunctionState.Selected">
            <summary>Has a check mark next to it to show that it is selected.</summary>
        </member>
        <member name="F:Animancer.Editor.MenuFunctionState.Disabled">
            <summary>Greyed out and unusable.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization">
            <summary>[Editor-Only] Various serialization utilities.</summary>
            <summary>[Editor-Only] Various serialization utilities.</summary>
            <summary>[Editor-Only] Various serialization utilities.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.ArrayDataPrefix">
            <summary>The text used in a <see cref="P:UnityEditor.SerializedProperty.propertyPath"/> to denote array elements.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.ArrayDataSuffix">
            <summary>The text used in a <see cref="P:UnityEditor.SerializedProperty.propertyPath"/> to denote array elements.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetFriendlyPath(UnityEditor.SerializedProperty)">
            <summary>Returns a user friendly version of the <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue(UnityEditor.SerializedProperty,System.Object)">
            <summary>Gets the value of the specified <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue(UnityEditor.SerializedProperty)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue``1(UnityEditor.SerializedProperty)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue``1(UnityEditor.SerializedProperty,``0@)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValues``1(UnityEditor.SerializedProperty)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/> for each of its target objects.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.SetValue(UnityEditor.SerializedProperty,System.Object,System.Object)">
            <summary>Sets the value of the specified <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.SetValue(UnityEditor.SerializedProperty,System.Object)">
            <summary>Sets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AreSameProperty(UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Indicates whether both properties refer to the same underlying field.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ForEachTarget(UnityEditor.SerializedProperty,System.Action{UnityEditor.SerializedProperty},System.String)">
            <summary>
            Executes the `action` once with a new <see cref="T:UnityEditor.SerializedProperty"/> for each of the
            <see cref="P:UnityEditor.SerializedObject.targetObjects"/>. Or if there is only one target, it uses the `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AddPropertyModifierFunction(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,System.String,Animancer.Editor.MenuFunctionState,System.Action{UnityEditor.SerializedProperty})">
            <summary>
            Adds a menu item to execute the specified `function` for each of the `property`s target objects.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AddPropertyModifierFunction(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,System.String,System.Boolean,System.Action{UnityEditor.SerializedProperty})">
            <summary>
            Adds a menu item to execute the specified `function` for each of the `property`s target objects.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AddPropertyModifierFunction(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,System.String,System.Action{UnityEditor.SerializedProperty})">
            <summary>
            Adds a menu item to execute the specified `function` for each of the `property`s target objects.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ModifyValues``1(UnityEditor.SerializedProperty,System.Action{``0},System.String)">
            <summary>
            Calls the specified `method` for each of the underlying values of the `property` (in case it represents
            multiple selected objects) and records an undo step for any modifications made.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.RecordUndo(UnityEditor.SerializedProperty,System.String)">
            <summary>
            Records the state of the specified `property` so it can be undone.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.OnPropertyChanged(UnityEditor.SerializedProperty)">
            <summary>
            Updates the specified `property` and marks its target objects as dirty so any changes to a prefab will be saved.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetPropertyType(System.Type)">
            <summary>
            Returns the <see cref="T:UnityEditor.SerializedPropertyType"/> that represents fields of the specified `type`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.RemoveArrayElement(UnityEditor.SerializedProperty,System.Int32)">
            <summary>Removes the specified array element from the `property`.</summary>
            <remarks>
            If the element is not at its default value, the first call to
            <see cref="M:UnityEditor.SerializedProperty.DeleteArrayElementAtIndex(System.Int32)"/> will only reset it, so this method will
            call it again if necessary to ensure that it actually gets removed.
            </remarks>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetAccessor(UnityEditor.SerializedProperty)">
            <summary>
            Returns an <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/> that can be used to access the details of the specified `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetAccessor(System.String,System.Type@)">
            <summary>
            Returns an <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/> for a <see cref="T:UnityEditor.SerializedProperty"/> with the specified `propertyPath`
            on the specified `type` of object.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetField(System.Type,System.String)">
            <summary>
            Returns a field with the specified `name` in the `declaringType` or any of its base types.
            </summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.PropertyAccessor">
            <summary>[Editor-Only]
            A wrapper for accessing the underlying values and fields of a <see cref="T:UnityEditor.SerializedProperty"/>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.PropertyAccessor.Parent">
            <summary>The accessor for the field which this accessor is nested inside.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.PropertyAccessor.Field">
            <summary>The field wrapped by this accessor.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.PropertyAccessor.FieldType">
            <summary>The type of the wrapped <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.#ctor(Animancer.Editor.Serialization.PropertyAccessor,System.Reflection.FieldInfo)">
            <summary>[Internal] Creates a new <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.#ctor(Animancer.Editor.Serialization.PropertyAccessor,System.Reflection.FieldInfo,System.Type)">
            <summary>Creates a new <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetValue(System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to get and return
            the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetValue(UnityEditor.SerializedObject)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to get and return
            the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetValue(UnityEditor.SerializedProperty)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to get and return
            the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.SetValue(System.Object,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to set the value
            of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.SetValue(UnityEditor.SerializedObject,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to set the value
            of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.SetValue(UnityEditor.SerializedProperty,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to set the value
            of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.ToString">
            <summary>Returns a description of this accessor's path.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetPath">
            <summary>Returns a this accessor's <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.ArrayPropertyAccessor">
            <summary>[Editor-Only]
            An <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/> for a particular element in an array.
            </summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.ArrayPropertyAccessor.ElementIndex">
            <summary>The index of the array element this accessor targets.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.#ctor(Animancer.Editor.Serialization.PropertyAccessor,System.Reflection.FieldInfo,System.Int32)">
            <summary>[Internal] Creates a new <see cref="T:Animancer.Editor.Serialization.ArrayPropertyAccessor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.GetElementType(System.Type)">
            <summary>Returns the type of elements in the array.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.GetValue(System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to
            get and return the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.SetValue(System.Object,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to
            set the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.ToString">
            <summary>Returns a description of this accessor's path.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ArrayPropertyAccessor.GetPath">
            <summary>Returns a this accessor's <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.ObjectReference">
            <summary>[Editor-Only]
            Directly serializing an <see cref="T:UnityEngine.Object"/> reference doesn't always work (such as with scene
            objects when entering Play Mode), so this class also serialized their instance ID and uses that if the direct
            reference fails.
            </summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.ObjectReference.Object">
            <summary>The referenced <see cref="T:UnityEditor.SerializedObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.ObjectReference.InstanceID">
            <summary>The <see cref="M:UnityEngine.Object.GetInstanceID"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.#ctor(UnityEngine.Object)">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.Serialization.ObjectReference"/> which wraps the specified
            <see cref="T:UnityEngine.Object"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.op_Implicit(UnityEngine.Object)~Animancer.Editor.Serialization.ObjectReference">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.Serialization.ObjectReference"/> which wraps the specified
            <see cref="T:UnityEngine.Object"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.op_Implicit(Animancer.Editor.Serialization.ObjectReference)~UnityEngine.Object">
            <summary>
            Returns the target <see cref="P:Animancer.Editor.Serialization.ObjectReference.Object"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.Convert(UnityEngine.Object[])">
            <summary>
            Creates a new array of <see cref="T:Animancer.Editor.Serialization.ObjectReference"/>s representing the `objects`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.Convert(Animancer.Editor.Serialization.ObjectReference[])">
            <summary>
            Creates a new array of <see cref="T:UnityEngine.Object"/>s containing the target <see cref="P:Animancer.Editor.Serialization.ObjectReference.Object"/> of each
            of the `references`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.AreSameObjects(Animancer.Editor.Serialization.ObjectReference[],UnityEngine.Object[])">
            <summary>
            Indicates whether both arrays refer to the same set of objects.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.ToString">
            <summary>Returns a string describing this object.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.IsValid(Animancer.Editor.Serialization.ObjectReference)">
            <summary>Returns true if the `reference` and <see cref="P:Animancer.Editor.Serialization.ObjectReference.Object"/> are not null.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.PropertyReference">
            <summary>[Editor-Only]
            A serializable reference to a <see cref="T:UnityEditor.SerializedProperty"/>.
            </summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.TargetObject">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedObject.targetObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.TargetObjects">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedObject.targetObjects"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.Context">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedObject.context"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.PropertyPath">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.IsInitialised">
            <summary>Indicates whether the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been accessed.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.Property">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The referenced <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.#ctor(UnityEditor.SerializedProperty)">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.Serialization.PropertyReference"/> which wraps the specified `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.op_Implicit(UnityEditor.SerializedProperty)~Animancer.Editor.Serialization.PropertyReference">
            <summary>
            Constructs a new <see cref="T:Animancer.Editor.Serialization.PropertyReference"/> which wraps the specified `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.op_Implicit(Animancer.Editor.Serialization.PropertyReference)~UnityEditor.SerializedProperty">
            <summary>
            Returns the target <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.IsTarget(UnityEditor.SerializedProperty,UnityEngine.Object[])">
            <summary>
            Returns true if the specified property and objects match the targets of this reference.
            </summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.TargetsExist">
            <summary>
            Returns true if there is at least one target and none of them are null.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.Update">
            <summary>
            Calls <see cref="M:UnityEditor.SerializedObject.Update"/> if the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been initialised.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.ApplyModifiedProperties">
            <summary>
            Calls <see cref="M:UnityEditor.SerializedObject.ApplyModifiedProperties"/> if the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been initialised.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.Dispose">
            <summary>
            Calls <see cref="M:UnityEditor.SerializedObject.Dispose"/> if the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been initialised.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.GetPropertyHeight">
            <summary>Gets the height needed to draw the target property.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.DoTargetGUI(UnityEngine.Rect)">
            <summary>Draws the target object within the specified `area`.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.DoPropertyGUI(UnityEngine.Rect)">
            <summary>Draws the target property within the specified `area`.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.IsValid(Animancer.Editor.Serialization.PropertyReference)">
            <summary>Returns true if the `reference` and <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> are not null.</summary>
        </member>
        <member name="T:Animancer.Editor.TemporarySettings">
            <summary>[Editor-Only]
            Stores data which needs to survive assembly reloading (such as from script compilation), but can be discarded
            when the Unity Editor is closed.
            </summary>
        </member>
        <member name="P:Animancer.Editor.TemporarySettings.Instance">
            <summary>
            Finds an existing instance of this class or creates a new one.
            </summary>
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewWindow">
            <summary>[Editor-Only] [Pro-Only]
            An <see cref="T:UnityEditor.EditorWindow"/> which allows the user to preview animation transitions separately from the rest
            of the scene in Edit Mode or Play Mode.
            </summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Icon">
            <summary>The icon image used by this window.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Open(UnityEditor.SerializedProperty,System.Boolean)">
            <summary>Focusses the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/> or creates one if none exists.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.PreviewNormalizedTime">
            <summary>
            The <see cref="P:Animancer.AnimancerState.NormalizedTime"/> of the current transition. Can only be set if the property
            being previewed matches the current <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.GetCurrentState">
            <summary>
            Returns the <see cref="T:Animancer.AnimancerState"/> of the current transition if the property being previewed matches
            the <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>. Otherwise returns null.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.IsPreviewingCurrentProperty">
            <summary>
            Indicates whether the current <see cref="P:Animancer.Editor.TransitionDrawer.TransitionContext.Property"/> is being previewed
            at the moment.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.CanBePreviewed(UnityEditor.SerializedProperty)">
            <summary>Indicates whether the `property` is able to be previewed by this system.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewWindow.Inspector">
            <summary>Inspector panel for the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewWindow.Scene">
            <summary>Temporary scene management for the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.TransitionPreviewWindow.Scene.HideAndDontSave">
            <summary><see cref="F:UnityEngine.HideFlags.HideAndDontSave"/> without <see cref="F:UnityEngine.HideFlags.NotEditable"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Scene.DestroyUnnecessaryComponents(UnityEngine.GameObject)">
            <summary>
            Destroys all unnecessary components on the preview instance while accounting for any
            <see cref="T:UnityEngine.RequireComponent"/> attributes.
            </summary>
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewWindow.Settings">
            <summary>Persistent settings for the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/>.</summary>
        </member>
        <member name="T:Animancer.AnimancerLayer">
             <summary>
             A layer on which animations can play with their states managed independantly of other layers while blending the
             output with those layers.
             <para></para>
             This class can be used as a custom yield instruction to wait until all animations finish playing.
             </summary>
            
             <remarks>
             See the documentation for more information about
             <see href="https://kybernetik.com.au/animancer/docs/manual/blending/layers">
             Layers</see>.
             </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.#ctor(Animancer.AnimancerPlayable,System.Int32)">
            <summary>[Internal] Constructs a new <see cref="T:Animancer.AnimancerLayer"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Playables.Playable"/> managed by this node.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.Layer">
            <summary>A layer is its own root.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.Parent">
            <summary>The <see cref="P:Animancer.AnimancerNode.Root"/> receives the output of the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.KeepChildrenConnected">
            <summary>Indicates whether child playables should stay connected to this mixer at all times.</summary>
        </member>
        <member name="F:Animancer.AnimancerLayer.States">
            <summary>All of the animation states connected to this layer.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.CurrentState">
            <summary>
            The state of the animation currently being played.
            <para></para>
            Specifically, this is the state that was most recently started using any of the Play or CrossFade methods
            on this layer. States controlled individually via methods in the <see cref="T:Animancer.AnimancerState"/> itself will
            not register in this property.
            <para></para>
            Each time this property changes, the <see cref="P:Animancer.AnimancerLayer.CommandCount"/> is incremented.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.CommandCount">
            <summary>
            The number of times the <see cref="P:Animancer.AnimancerLayer.CurrentState"/> has changed. By storing this value and later comparing
            the stored value to the current value, you can determine whether the state has been changed since then,
            even it has changed back to the same state.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.IsAdditive">
            <summary>[Pro-Only]
            Determines whether this layer is set to additive blending. Otherwise it will override any earlier layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.SetMask(UnityEngine.AvatarMask)">
            <summary>[Pro-Only]
            Sets an <see cref="T:UnityEngine.AvatarMask"/> to determine which bones this layer will affect.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerLayer._Mask">
            <summary>[Editor-Only]
            The <see cref="T:UnityEngine.AvatarMask"/> that determines which bones this layer will affect.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.AverageVelocity">
            <summary>
            The average velocity of the root motion of all currently playing animations, taking their current
            <see cref="P:Animancer.AnimancerNode.Weight"/> into account.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.ChildCount">
            <summary>The number of states using this layer as their <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetChild(System.Int32)">
            <summary>Returns the state connected to the specified `index` as a child of this layer.</summary>
            <remarks>This method is identical to <see cref="P:Animancer.AnimancerLayer.Item(System.Int32)"/>.</remarks>
        </member>
        <member name="P:Animancer.AnimancerLayer.Item(System.Int32)">
            <summary>Returns the state connected to the specified `index` as a child of this layer.</summary>
            <remarks>This indexer is identical to <see cref="M:Animancer.AnimancerLayer.GetChild(System.Int32)"/>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.AddChild(Animancer.AnimancerState)">
            <summary>
            Adds a new port and uses <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> to connect the `state` to it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnAddChild(Animancer.AnimancerState)">
            <summary>Connects the `state` to this layer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnRemoveChild(Animancer.AnimancerState)">
            <summary>Disconnects the `state` from this layer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetEnumerator">
            <summary>
            Returns an enumerator that will iterate through all states connected directly to this layer (not inside
            <see cref="T:Animancer.MixerState"/>s).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip`.
            </summary>
            <remarks>
            <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> is used to determine the <see cref="P:Animancer.AnimancerState.Key"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState(System.Object,UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` and registers it with the `key`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState``1">
            <summary>Creates and returns a new <typeparamref name="T"/> attached to this layer.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateIfNew(UnityEngine.AnimationClip[])">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> and returns the state which registered with that key or
            creates one if it doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateState(Animancer.ITransition)">
            <summary>
            Returns the state registered with the <see cref="P:Animancer.IHasKey.Key"/> if there is one. Otherwise
            this method uses <see cref="M:Animancer.ITransition.CreateState"/> to create a new one and registers it with
            that key before returning it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateState(System.Object,UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Returns the state which registered with the `key` or creates one if it doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            <seealso cref="T:Animancer.AnimancerState"/>
            </summary>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
            <remarks>
            See also: <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(System.Object,UnityEngine.AnimationClip,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.DestroyStates">
            <summary>
            Destroys all states connected to this layer. This operation cannot be undone.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnStartFade">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/> (when this layer starts fading, not when one of its states
            starts fading). Clears the <see cref="P:Animancer.AnimancerState.Events"/> of all states.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(UnityEngine.AnimationClip)">
            <summary>
            Stops all other animations, plays the `clip`, and returns its state.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            To restart it from the beginning you can use <c>...Play(clip).Time = 0;</c>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)">
            <summary>
            Stops all other animations, plays the `state`, and returns it.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the `state`s time to 0.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.ITransition)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on the <see cref="P:Animancer.ITransition.FadeDuration"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(System.Object)">
            <summary>
            Stops all other animations, plays the animation registered with the `key`, and returns that
            state. If no state is registered with the `key`, this method does nothing and returns null.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the returned state's time to 0.
            on the returned state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(UnityEngine.AnimationClip,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `clip` over the course of the `fadeDuration` while fading out all others in the same
            layer. Returns its state.
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `state` over the course of the `fadeDuration` while fading out all others in this
            layer. Returns the `state`.
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.ITransition,System.Single,Animancer.FadeMode)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on the <see cref="P:Animancer.ITransition.FadeDuration"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(System.Object,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the animation registered with the `key` over the course of the `fadeDuration` while fading
            out all others in the same layer. Returns the animation's state (or null if none was registered).
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.EvaluateFadeMode(Animancer.FadeMode,Animancer.AnimancerState@,System.Single@)">
            <summary>
            Manipulates the other parameters according to the `mode`.
            </summary>
            <exception cref="T:System.ArgumentException">
            The <see cref="P:Animancer.AnimancerState.Clip"/> is null when using <see cref="F:Animancer.FadeMode.FromStart"/> or
            <see cref="F:Animancer.FadeMode.NormalizedFromStart"/>.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerLayer.MaxStateDepth">
            <summary>[Assert-Only]
            The maximum number of duplicate states that can be created by <see cref="M:Animancer.AnimancerLayer.GetOrCreateWeightlessState(Animancer.AnimancerState)"/> for
            a single clip before it will start giving usage warnings. Default = 5.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.SetMaxStateDepth(System.Int32)">
            <summary>[Assert-Conditional] Sets the <see cref="P:Animancer.AnimancerLayer.MaxStateDepth"/>.</summary>
            <remarks>This would not need to be a separate method if C# supported conditional property setters.</remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateWeightlessState(Animancer.AnimancerState)">
            <summary>
            If the `state` is not currently at 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method finds a copy of it
            which is at 0 or creates a new one.
            </summary>
            <exception cref="T:System.InvalidOperationException">The <see cref="P:Animancer.AnimancerState.Clip"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            More states have been created for this <see cref="P:Animancer.AnimancerState.Clip"/> than the
            <see cref="P:Animancer.AnimancerLayer.MaxStateDepth"/> allows.
            </exception>
        </member>
        <member name="M:Animancer.AnimancerLayer.Stop">
            <summary>
            Sets <see cref="P:Animancer.AnimancerNode.Weight"/> = 0 and calls <see cref="M:Animancer.AnimancerState.Stop"/> on all animations
            to stop them from playing and rewind them to the start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsPlayingClip(UnityEngine.AnimationClip)">
            <summary>
            Returns true if the `clip` is currently being played by at least one state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsAnyStatePlaying">
            <summary>
            Returns true if at least one animation is being played.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsPlayingAndNotEnding">
            <summary>
            Returns true if the <see cref="P:Animancer.AnimancerLayer.CurrentState"/> is playing and hasn't yet reached its end.
            <para></para>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetTotalWeight">
            <summary>
            Calculates the total <see cref="P:Animancer.AnimancerNode.Weight"/> of all states in this layer.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in this layer.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.ToString">
            <summary>The Inspector display name of this layer.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)"/> to append the details of this node.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerNode">
            <summary>
            Base class for <see cref="T:UnityEngine.Playables.Playable"/> wrapper objects in <see cref="N:Animancer"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerNode._Playable">
            <summary>
            The internal object this node manages in the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            <para></para>
            Must be set by <see cref="M:Animancer.AnimancerNode.CreatePlayable"/>. Failure to do so will throw the following exception throughout
            the system when using this node: "<see cref="T:System.ArgumentException"/>: The playable passed as an argument is
            invalid. To create a valid playable, please use the appropriate Create method".
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Animancer#IPlayableWrapper#Playable">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> managed by this node.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.IsValid">
            <summary>
            Indicates whether the <see cref="F:Animancer.AnimancerNode._Playable"/> is usable (properly initialised and not destroyed).
            </summary>
        </member>
        <member name="F:Animancer.AnimancerNode._IsInspectorExpanded">
            <summary>[Editor-Only] [Internal] Indicates whether the Inspector details for this node are expanded.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.CreatePlayable">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Playables.Playable"/> managed by this node.</summary>
            <remarks>
            This method also applies the <see cref="P:Animancer.AnimancerNode.Speed"/> if it was set beforehand.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerNode.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Playables.Playable"/> managed by this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.DestroyPlayable">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.RecreatePlayable">
            <summary>Calls <see cref="M:Animancer.AnimancerNode.DestroyPlayable"/> and <see cref="M:Animancer.AnimancerNode.CreatePlayable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.RecreatePlayableRecursive">
            <summary>Calls <see cref="M:Animancer.AnimancerNode.RecreatePlayable"/> on this node and all its children recursively.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Layer">
            <summary>The root <see cref="T:Animancer.AnimancerLayer"/> which this node is connected to.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Parent">
            <summary>The object which receives the output of this node.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Index">
            <summary>
            The index of the port this node is connected to on the parent's <see cref="T:UnityEngine.Playables.Playable"/>.
            <para></para>
            A negative value indicates that it is not assigned to a port.
            </summary>
            <remarks>
            Indices are generally assigned starting from 0, ascending in the order they are connected to their layer.
            They will not usually change unless the <see cref="P:Animancer.AnimancerNode.Parent"/> changes or another state on the same layer is
            destroyed so the last state is swapped into its place to avoid shuffling everything down to cover the gap.
            <para></para>
            The setter is internal so user defined states cannot set it incorrectly. Ideally,
            <see cref="T:Animancer.AnimancerLayer"/> should be able to set the port in its constructor and
            <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> should also be able to set it, but classes that further inherit from
            there should not be able to change it without properly calling that method.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerNode.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.AnimancerNode"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ConnectToGraph">
            <summary>[Internal] Connects the <see cref="T:UnityEngine.Playables.Playable"/> to the <see cref="P:Animancer.AnimancerNode.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.DisconnectFromGraph">
            <summary>[Internal] Disconnects the <see cref="T:UnityEngine.Playables.Playable"/> from the <see cref="P:Animancer.AnimancerNode.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.RequireUpdate">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.RequireUpdate(Animancer.AnimancerNode)"/> as long as the <see cref="P:Animancer.AnimancerNode.Root"/> is not
            null.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Update(System.Boolean@)">
            <summary>
            Updates the <see cref="P:Animancer.AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays
            or pauses the <see cref="T:UnityEngine.Playables.Playable"/> if its state is dirty.
            <para></para>
            If the <see cref="P:Animancer.AnimancerNode.Parent"/>'s <see cref="P:Animancer.AnimancerNode.KeepChildrenConnected"/> is set to false, this method will
            also connect/disconnect this node from the <see cref="P:Animancer.AnimancerNode.Parent"/> in the playable graph.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.IsPlayingAndNotEnding">
            <summary>
            Returns true if the animation is playing and hasn't yet reached its end.
            <para></para>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.System#Collections#IEnumerator#MoveNext">
            <summary>Calls <see cref="M:Animancer.AnimancerNode.IsPlayingAndNotEnding"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.System#Collections#IEnumerator#Current">
            <summary>Returns null.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.System#Collections#IEnumerator#Reset">
            <summary>Does nothing.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.ChildCount">
            <summary>The number of states using this node as their <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetChild(System.Int32)">
            <summary>
            Returns the state connected to the specified `index` as a child of this node.
            </summary>
            <exception cref="T:System.NotSupportedException">This node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnAddChild(Animancer.AnimancerState)">
            <summary>
            Called when a child is connected with this node as its <see cref="P:Animancer.AnimancerState.Parent"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">This node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnRemoveChild(Animancer.AnimancerState)">
            <summary>
            Called when a child's <see cref="P:Animancer.AnimancerState.Parent"/> is changed from this node to something else.
            </summary>
            <exception cref="T:System.NotSupportedException">This node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnAddChild(System.Collections.Generic.IList{Animancer.AnimancerState},Animancer.AnimancerState)">
            <summary>Connects the `state` to this node at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
            <exception cref="T:System.InvalidOperationException">The <see cref="P:Animancer.AnimancerNode.Index"/> was already occupied.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnChildDestroyed(Animancer.AnimancerState)">
            <summary>[Internal]
            Called by <see cref="M:Animancer.AnimancerState.Destroy"/> for any states connected to this mixer.
            Adds the `state`s port to a list of spares to be reused by another state and notifies the root
            <see cref="T:Animancer.AnimancerPlayable"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.KeepChildrenConnected">
            <summary>
            Indicates whether child playables should stay connected to this mixer at all times (default false).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ConnectAllChildrenToGraph">
            <summary>
            Ensures that all children of this node are connected to the <see cref="F:Animancer.AnimancerNode._Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.DisconnectWeightlessChildrenFromGraph">
            <summary>
            Ensures that all children of this node which have zero weight are disconnected from the
            <see cref="F:Animancer.AnimancerNode._Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetEnumerator">
            <summary>Gets an enumerator for all of this node's child states.</summary>
        </member>
        <member name="F:Animancer.AnimancerNode._Weight">
            <summary>The current blend weight of this node. Accessed via <see cref="P:Animancer.AnimancerNode.Weight"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerNode._IsWeightDirty">
            <summary>Indicates whether the weight has changed and should be applied to the parent mixer.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Weight">
             <summary>
             The current blend weight of this node which determines how much it affects the final output. 0 has no
             effect while 1 applies the full effect of this node and values inbetween apply a proportional effect.
             <para></para>
             Setting this property cancels any fade currently in progress. If you don't wish to do that, you can use
             <see cref="M:Animancer.AnimancerNode.SetWeight(System.Single)"/> instead.
             <para></para>
             Animancer Lite only allows this value to be set to 0 or 1 in a runtime build.
             </summary>
            
             <example>
             Calling <see cref="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip)"/> immediately sets the weight of all states to 0
             and the new state to 1. Note that this is separate from other values like
             <see cref="P:Animancer.AnimancerState.IsPlaying"/> so a state can be paused at any point and still show its pose on the
             character or it could be still playing at 0 weight if you want it to still trigger events (though states
             are normally stopped when they reach 0 weight so you would need to explicitly set it to playing again).
             <para></para>
             Calling <see cref="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip,System.Single,Animancer.FadeMode)"/> does not immediately change
             the weights, but instead calls <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/> on every state to set their
             <see cref="P:Animancer.AnimancerNode.TargetWeight"/> and <see cref="P:Animancer.AnimancerNode.FadeSpeed"/>. Then every update each state's weight will move
             towards that target value at that speed.
             </example>
        </member>
        <member name="M:Animancer.AnimancerNode.SetWeight(System.Single)">
            <summary>
            Sets the current blend weight of this node which determines how much it affects the final output.
            0 has no effect while 1 applies the full effect of this node.
            <para></para>
            This method allows any fade currently in progress to continue. If you don't wish to do that, you can set
            the <see cref="P:Animancer.AnimancerNode.Weight"/> property instead.
            <para></para>
            Animancer Lite only allows this value to be set to 0 or 1 in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.SetWeightDirty">
            <summary>
            Flags this node as having a dirty weight that needs to be applied next update.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ApplyWeight">
            <summary>[Internal]
            Applies the <see cref="P:Animancer.AnimancerNode.Weight"/> to the connection between this node and its <see cref="P:Animancer.AnimancerNode.Parent"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.TargetWeight">
            <summary>
            The desired <see cref="P:Animancer.AnimancerNode.Weight"/> which this node is fading towards according to the
            <see cref="P:Animancer.AnimancerNode.FadeSpeed"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.FadeSpeed">
            <summary>
            The speed at which this node is fading towards the <see cref="P:Animancer.AnimancerNode.TargetWeight"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerNode.OnStartFade"/> and starts fading the <see cref="P:Animancer.AnimancerNode.Weight"/> over the course
            of the `fadeDuration` (in seconds).
            <para></para>
            If the `targetWeight` is 0 then <see cref="M:Animancer.AnimancerNode.Stop"/> will be called when the fade is complete.
            <para></para>
            If the <see cref="P:Animancer.AnimancerNode.Weight"/> is already equal to the `targetWeight` then the fade will end
            immediately.
            <para></para>
            Animancer Lite only allows a `targetWeight` of 0 or 1 and the default `fadeDuration` in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.OnStartFade">
            <summary>Called by <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Stop">
            <summary>
            Stops the animation and makes it inactive immediately so it no longer affects the output.
            Sets <see cref="P:Animancer.AnimancerNode.Weight"/> = 0 by default.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.UpdateFade(System.Boolean@)">
            <summary>
            Moves the <see cref="P:Animancer.AnimancerNode.Weight"/> towards the <see cref="P:Animancer.AnimancerNode.TargetWeight"/> according to the
            <see cref="P:Animancer.AnimancerNode.FadeSpeed"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.ApplyAnimatorIK">
            <summary>[<see cref="T:Animancer.IHasIK"/>]
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object while this
            node is active. The initial value is determined by <see cref="P:Animancer.AnimancerPlayable.DefaultApplyAnimatorIK"/>.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers.
            <para></para>
            Note that this property only applies to <see cref="T:Animancer.ClipState"/>s.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.ApplyFootIK">
            <summary>[<see cref="T:Animancer.IHasIK"/>]
            Determines whether this node is applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerPlayable.DefaultApplyFootIK"/>.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Speed">
             <summary>[Pro-Only]
             How fast the <see cref="P:Animancer.AnimancerState.Time"/> is advancing every frame.
             <para></para>
             1 is the normal speed.
             <para></para>
             A negative value will play the animation backwards.
             </summary>
             
             <remarks>
             Instead of setting this value to 0 to pause an animation, consider setting
             <see cref="P:Animancer.AnimancerState.IsPlaying"/> to false.
             </remarks>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.Speed = 1;// Normal speed.
                 state.Speed = 2;// Double speed.
                 state.Speed = 0.5f;// Half speed.
                 state.Speed = -1;// Normal speed playing backwards.
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerNode.ParentEffectiveSpeed">
            <summary>
            The multiplied <see cref="P:Animancer.AnimancerNode.Speed"/> of each of this node's parents down the hierarchy, excluding the root
            <see cref="P:Animancer.AnimancerPlayable.Speed"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.EffectiveSpeed">
            <summary>
            The <see cref="P:Animancer.AnimancerNode.Speed"/> of this node multiplied by the <see cref="P:Animancer.AnimancerNode.Speed"/> of each of its parents down the
            hierarchy (including the root <see cref="P:Animancer.AnimancerPlayable.Speed"/>) to determine the actual speed its
            output is being played at.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Name">
            <summary>[Editor-Only] The Inspector display name of this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ToString">
            <summary>The Inspector display name of this layer.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.SetName(System.String)">
            <summary>[Editor-Conditional]
            Sets the Inspector display name of this node. <see cref="M:Animancer.AnimancerNode.ToString"/> returns the name.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetDescription(System.Int32,System.String)">
            <summary>Returns a detailed descrption of the current details of this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)">
            <summary>Appends a detailed descrption of the current details of this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)"/> to append the details of this node.</summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable">
            <summary>
            A <see cref="T:UnityEngine.Playables.PlayableBehaviour"/> which can be used as a substitute for the
            <see cref="T:UnityEngine.RuntimeAnimatorController"/> normally used to control an <see cref="T:UnityEngine.Animator"/>.
            <para></para>
            This class can be used as a custom yield instruction to wait until all animations finish playing.
            <para></para>
            The most common way to access this class is via <see cref="!:AnimancerComponent.Playable"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.DefaultFadeDuration">
            <summary>The fade duration to use if the caller doesn't specify.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._Graph">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.PlayableGraph"/> containing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Graph">
            <summary>[Pro-Only] The <see cref="T:UnityEngine.Playables.PlayableGraph"/> containing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._RootPlayable">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> containing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._LayerMixer">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> which layers connect to.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Animancer#IPlayableWrapper#Playable">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> which layers connect to.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Animancer#IPlayableWrapper#Parent">
            <summary>An <see cref="T:Animancer.AnimancerPlayable"/> is the root of the graph so it has no parent.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Layers">
            <summary>The <see cref="T:Animancer.AnimancerLayer"/>s which each manage their own set of animations.</summary>
            <remarks>
            See the documentation for more information about
            <see href="https://kybernetik.com.au/animancer/docs/manual/blending/layers">
            Layers</see>.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerPlayable.States">
            <summary>The <see cref="T:Animancer.AnimancerState"/>s managed by this playable.</summary>
            <remarks>
            See the documentation for more information about
            <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">
            States</see>.
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerPlayable._DirtyNodes">
            <summary>All of the nodes that need to be updated.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._Updatables">
            <summary>All of the objects that need to be updated early.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._LateUpdate">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableBehaviour"/> that calls <see cref="M:Animancer.IUpdatable.LateUpdate"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Component">
            <summary>The component that is playing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.CommandCount">
            <summary>
            The number of times the <see cref="P:Animancer.AnimancerPlayable.StateDictionary.Current"/> has changed. By storing this
            value and later comparing the stored value to the current value, you can determine whether the state has
            been changed since then, even it has changed back to the same state.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.UpdateMode">
            <summary>Determines what time source is used to update the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Speed">
             <summary>
             How fast the <see cref="P:Animancer.AnimancerState.Time"/> of all animations is advancing every frame.
             <para></para>
             1 is the normal speed.
             <para></para>
             A negative value will play the animations backwards.
             <para></para>
             Setting this value to 0 would pause all animations, but calling <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/> is more efficient.
             <para></para>
             Animancer Lite does not allow this value to be changed in a runtime build.
             </summary>
            
             <example>
             <code>
             void SetSpeed(AnimancerComponent animancer)
             {
                 animancer.Playable.Speed = 1;// Normal speed.
                 animancer.Playable.Speed = 2;// Double speed.
                 animancer.Playable.Speed = 0.5f;// Half speed.
                 animancer.Playable.Speed = -1;// Normal speed playing backwards.
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerPlayable.KeepChildrenConnected">
            <summary>
            Indicates whether child playables should stay connected to the graph at all times.
            </summary>
            
            <remarks>
            Humanoid Rigs default this value to <c>false</c> so that playables will be disconnected from the graph
            while they are at 0 weight which stops it from evaluating them every frame.
            <para></para>
            Generic Rigs default this value to <c>true</c> because they do not always animate the same standard set of
            values so every connection change has a higher performance cost than with Humanoid Rigs which is generally
            more significant than the gains for having fewer playables connected at a time.
            <para></para>
            The default is set by <see cref="M:Animancer.AnimancerPlayable.SetOutput(UnityEngine.Animator,Animancer.IAnimancerComponent)"/>.
            </remarks>
            
            <example><code>
            [SerializeField]
            private AnimancerComponent _Animancer;
            
            public void Initialise()
            {
                _Animancer.Playable.KeepChildrenConnected = true;
            }
            </code></example>
        </member>
        <member name="F:Animancer.AnimancerPlayable.Template">
            <summary>
            Since <see cref="M:UnityEngine.Playables.ScriptPlayable`1.Create(UnityEngine.Playables.PlayableGraph,System.Int32)"/> needs to clone an existing instance, we
            keep a static template to avoid allocating an extra garbage one every time. This is why the fields are
            assigned in <see cref="M:Animancer.AnimancerPlayable.OnPlayableCreate(UnityEngine.Playables.Playable)"/> rather than being readonly with field initialisers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Create">
            <summary>
            Creates a new <see cref="T:UnityEngine.Playables.PlayableGraph"/> containing an <see cref="T:Animancer.AnimancerPlayable"/>.
            <para></para>
            The caller is responsible for calling <see cref="M:Animancer.AnimancerPlayable.Destroy"/> on the returned object, except in Edit Mode
            where it will be called automatically.
            <para></para>
            Consider calling <see cref="M:Animancer.AnimancerPlayable.SetNextGraphName(System.String)"/> before this method to give it a name.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.OnPlayableCreate(UnityEngine.Playables.Playable)">
            <summary>[Internal] Called by Unity as it creates this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.SetNextGraphName(System.String)">
            <summary>[Editor-Conditional]
            Sets the display name for the next <see cref="M:Animancer.AnimancerPlayable.Create"/> call to give its <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
            <remarks>
            Having this method separate from <see cref="M:Animancer.AnimancerPlayable.Create"/> allows the
            <see cref="T:System.Diagnostics.ConditionalAttribute"/> to compile it out of runtime builds which would
            otherwise require #ifs on the caller side.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.ToString">
            <summary>[Editor-Only] Returns "AnimancerPlayable (Graph Name)".</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.SetOutput(Animancer.IAnimancerComponent)">
            <summary>
            Plays this playable on the <see cref="P:Animancer.IAnimancerComponent.Animator"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.SetOutput(UnityEngine.Animator,Animancer.IAnimancerComponent)">
            <summary>
            Plays this playable on the specified `animator`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.InsertOutputPlayable(UnityEngine.Playables.Playable)">
            <summary>[Pro-Only]
            Inserts a `playable` after the root of the <see cref="P:Animancer.AnimancerPlayable.Graph"/> so that it can modify the final output.
            <para></para>
            It can be removed using <see cref="M:Animancer.AnimancerUtilities.RemovePlayable(UnityEngine.Playables.Playable,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.InsertOutputJob``1(``0)">
            <summary>[Pro-Only]
            Inserts an animation job after the root of the <see cref="P:Animancer.AnimancerPlayable.Graph"/> so that it can modify the final output.
            <para></para>
            It can can be removed by passing the returned value into <see cref="M:Animancer.AnimancerUtilities.RemovePlayable(UnityEngine.Playables.Playable,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.IsValid">
            <summary>
            Returns true as long as the <see cref="T:UnityEngine.Playables.PlayableGraph"/> hasn't been destroyed (such as by <see cref="M:Animancer.AnimancerPlayable.Destroy"/>).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Destroy">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.PlayableGraph"/>. This operation cannot be undone.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.OnPlayableDestroy(UnityEngine.Playables.Playable)">
            <summary>Cleans up the resources managed by this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Disposables">
            <summary>A list of objects that need to be disposed when this <see cref="T:Animancer.AnimancerPlayable"/> is destroyed.</summary>
            <remarks>This list is primarily used to dispose native arrays used in Animation Jobs.</remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Finalize">
            <summary>Calls <see cref="M:System.IDisposable.Dispose"/> on all the <see cref="P:Animancer.AnimancerPlayable.Disposables"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.DisposeAll">
            <summary>Calls <see cref="M:System.IDisposable.Dispose"/> on all the <see cref="P:Animancer.AnimancerPlayable.Disposables"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.DefaultApplyAnimatorIK">
            <summary>
            Determines the default value of <see cref="P:Animancer.AnimancerNode.ApplyAnimatorIK"/> for all new states created in
            this layer. Default false.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.ApplyAnimatorIK">
            <summary>[<see cref="T:Animancer.IHasIK"/>]
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object for any
            <see cref="P:Animancer.AnimancerPlayable.States"/>. The initial value is determined by <see cref="P:Animancer.AnimancerPlayable.DefaultApplyAnimatorIK"/> when a new
            state is created and setting this value will also set the default.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers, except that due to limitations in
            the Playables API the <c>layerIndex</c> will always be zero.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.DefaultApplyFootIK">
            <summary>
            Determines the default value of <see cref="P:Animancer.AnimancerNode.ApplyFootIK"/> for all new states created in this
            layer. Default false.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.ApplyFootIK">
            <summary>[<see cref="T:Animancer.IHasIK"/>]
            Determines whether any of the <see cref="P:Animancer.AnimancerPlayable.States"/> in this layer are applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerPlayable.DefaultApplyFootIK"/> when a new state is created.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states (applied to the whole layer).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)">
            <summary>Calls <see cref="M:Animancer.IAnimancerComponent.GetKey(UnityEngine.AnimationClip)"/> on the <see cref="P:Animancer.AnimancerPlayable.Component"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip)">
            <summary>
            Stops all other animations on the same layer, plays the `clip`, and returns its state.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            To restart it from the beginning you can use <c>...Play(clip, layerIndex).Time = 0;</c>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)">
            <summary>
            Stops all other animations on the same laye, plays the `state`, and returns it.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the `state`s time to 0.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `clip` while fading out all other states in the same layer over the course of the
            `fadeDuration`. Returns its state.
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `state` while fading out all others in the same layer over the course of the
            `fadeDuration`. Returns the `state`.
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on the <see cref="P:Animancer.ITransition.FadeDuration"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition,System.Single,Animancer.FadeMode)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on the <see cref="P:Animancer.ITransition.FadeDuration"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.TryPlay(System.Object)">
            <summary>
            Stops all other animations on the same layer, plays the animation registered with the `key`, and returns
            that state.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the returned state's time to 0.
            on the returned state.
            </summary>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No state is registered with the `key`.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.TryPlay(System.Object,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the animation registered with the `key` while fading out all others in the same layer
            over the course of the `fadeDuration`.
            <para></para>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in a runtime build.
            </summary>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No state is registered with the `key`.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(Animancer.IHasKey)">
            <summary>
            Gets the state registered with the <see cref="P:Animancer.IHasKey.Key"/>, stops and rewinds it to the start, then
            returns it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(System.Object)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Stop"/> on the state registered with the `key` to stop it from playing and
            rewind it to the start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Stop"/> on all animations to stop them from playing and rewind them to the
            start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(Animancer.IHasKey)">
            <summary>
            Returns true if a state is registered with the <see cref="P:Animancer.IHasKey.Key"/> and it is currently playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(System.Object)">
            <summary>
            Returns true if a state is registered with the `key` and it is currently playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying">
            <summary>
            Returns true if at least one animation is being played.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlayingClip(UnityEngine.AnimationClip)">
            <summary>
            Returns true if the `clip` is currently being played by at least one state in the specified layer.
            <para></para>
            This method is inefficient because it searches through every state to find any that are playing the `clip`,
            unlike <see cref="M:Animancer.AnimancerPlayable.IsPlaying(System.Object)"/> which only checks the state registered using the specified key.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetTotalWeight">
            <summary>
            Calculates the total <see cref="P:Animancer.AnimancerNode.Weight"/> of all states in this playable.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in all layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetEnumerator">
            <summary>
            Returns an enumerator that will iterate through all states in each layer (but not sub-states).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.System#Collections#IEnumerator#MoveNext">
            <summary>
            Determines if any animations are still playing so this object can be used as a custom yield instruction.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.System#Collections#IEnumerator#Current">
            <summary>Returns null.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.System#Collections#IEnumerator#Reset">
            <summary>Does nothing.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            Just call <see cref="M:Animancer.AnimancerState.Stop"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            Just check <see cref="P:Animancer.AnimancerState.IsPlaying"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.IsGraphPlaying">
            <summary>Indicates whether the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is currently playing.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.UnpauseGraph">
            <summary>
            Resumes playing the <see cref="T:UnityEngine.Playables.PlayableGraph"/> if <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/> was called previously.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PauseGraph">
            <summary>
            Freezes the <see cref="T:UnityEngine.Playables.PlayableGraph"/> at its current state.
            <para></para>
            If you call this method, you are responsible for calling <see cref="M:Animancer.AnimancerPlayable.UnpauseGraph"/> to resume playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Evaluate">
            <summary>
            Evaluates all of the currently playing animations to apply their states to the animated objects.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Evaluate(System.Single)">
            <summary>
            Advances all currently playing animations by the specified amount of time (in seconds) and evaluates the
            graph to apply their states to the animated objects.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetDescription(System.Int32)">
            <summary>Returns a detailed descrption of all currently playing states and other registered states.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.AppendDescription(System.Text.StringBuilder,System.Int32)">
            <summary>Appends a detailed descrption of all currently playing states and other registered states.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.AppendInternalDetails(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Appends a list of all <see cref="T:Animancer.IUpdatable"/>s and <see cref="T:Animancer.AnimancerNode"/>s that are registered for updates.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RequireUpdate(Animancer.IUpdatable)">
            <summary>
            Adds the `updatable` to the list of objects that need to be updated if it was not there already.
            <para></para>
            This method is safe to call at any time, even during an update.
            <para></para>
            The execution order of updatables is non-deterministic. Specifically, the most recently added will be
            updated first and <see cref="M:Animancer.AnimancerPlayable.CancelUpdate(Animancer.IUpdatable)"/> will change the order by swapping the last one
            into the place of the removed element.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CancelUpdate(Animancer.IUpdatable)">
            <summary>
            Removes the `updatable` from the list of objects that need to be updated.
            <para></para>
            This method is safe to call at any time, even during an update.
            <para></para>
            The last element is swapped into the place of the one being removed so that the rest of them do not need to
            be moved down one place to fill the gap. This is more efficient, but means that the update order can change.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RequireUpdate(Animancer.AnimancerNode)">
            <summary>
            Adds the `node` to the list that need to be updated if it was not there already.
            <para></para>
            This method is safe to call at any time, even during an update.
            <para></para>
            The execution order of nodes is non-deterministic. Specifically, the most recently added will be
            updated first and <see cref="M:Animancer.AnimancerPlayable.CancelUpdate(Animancer.AnimancerNode)"/> will change the order by swapping the last one
            into the place of the removed element.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CancelUpdate(Animancer.AnimancerNode)">
            <summary>
            Removes the `node` from the list of objects that need to be updated.
            <para></para>
            This method is safe to call at any time, even during an update.
            <para></para>
            The last element is swapped into the place of the one being removed so that the rest of them do not need to
            be moved down one place to fill the gap. This is more efficient, but means that the update order can change.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Current">
            <summary>The object currently executing <see cref="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.DeltaTime">
            <summary>
            The current (most recent) <see cref="P:UnityEngine.Playables.FrameData.deltaTime"/>.
            <para></para>
            After <see cref="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/>, this property will be left at its most recent value.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.FrameID">
            <summary>
            The current (most recent) <see cref="P:UnityEngine.Playables.FrameData.frameId"/>.
            <para></para>
            <see cref="P:Animancer.AnimancerState.Time"/> uses this value to determine whether it has accessed the playable's time
            since it was last updated in order to cache its value.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._CurrentUpdatable">
            <summary>The index of the <see cref="T:Animancer.IUpdatable"/> currently being updated.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._CurrentNode">
            <summary>The index of the <see cref="T:Animancer.AnimancerNode"/> currently being updated.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.UpdatableLoopStartError">
            <summary>An error message for potential multithreading issues.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
            <summary>[Internal]
            Called by the <see cref="T:UnityEngine.Playables.PlayableGraph"/> before the rest of the <see cref="T:UnityEngine.Playables.Playable"/>s are evaluated.
            Calls <see cref="M:Animancer.IUpdatable.EarlyUpdate"/> and <see cref="M:Animancer.AnimancerNode.Update(System.Boolean@)"/> on everything
            that needs it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsRunningLateUpdate(Animancer.AnimancerPlayable)">
            <summary>Indicates whether the internal <see cref="T:Animancer.AnimancerPlayable.LateUpdate"/> is currently executing.</summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable.LateUpdate">
            <summary>
            A <see cref="T:UnityEngine.Playables.PlayableBehaviour"/> which connects to a later port than the main layer mixer so that its
            <see cref="M:Animancer.AnimancerPlayable.LateUpdate.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/> method gets called after all other playables are updated in order to call
            <see cref="M:Animancer.IUpdatable.LateUpdate"/> on the <see cref="F:Animancer.AnimancerPlayable._Updatables"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LateUpdate.Template">
            <summary>See <see cref="F:Animancer.AnimancerPlayable.Template"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LateUpdate._Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> this behaviour is connected to.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LateUpdate._Playable">
            <summary>The underlying <see cref="T:UnityEngine.Playables.Playable"/> of this behaviour.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LateUpdate.Create(Animancer.AnimancerPlayable)">
            <summary>Creates a new <see cref="T:Animancer.AnimancerPlayable.LateUpdate"/> for the `root`.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LateUpdate.OnPlayableCreate(UnityEngine.Playables.Playable)">
            <summary>Called by Unity as it creates this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LateUpdate.IsConnected">
            <summary>
            Indicates whether this behaviour is connected to the <see cref="T:UnityEngine.Playables.PlayableGraph"/> and thus, whether it
            will receive <see cref="M:Animancer.AnimancerPlayable.LateUpdate.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/> calls.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LateUpdate.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
            <summary>
            Called by the <see cref="T:UnityEngine.Playables.PlayableGraph"/> after the rest of the <see cref="T:UnityEngine.Playables.Playable"/>s are evaluated.
            Calls <see cref="M:Animancer.IUpdatable.LateUpdate"/> on everything that needs it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RegisterInstance">
            <summary>[Editor-Only]
            Registers this object in the list of things that need to be cleaned up in Edit Mode.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.ShouldStayAlive">
            <summary>
            Determines whether this playable should stay alive or be destroyed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.HasChangedToOrFromAnimatePhysics(System.Nullable{UnityEngine.AnimatorUpdateMode},UnityEngine.AnimatorUpdateMode)">
            <summary>[Editor-Only]
            Returns true if the `initial` mode was <see cref="F:UnityEngine.AnimatorUpdateMode.AnimatePhysics"/> and the `current`
            has changed to another mode or if the `initial` mode was something else and the `current` has changed to
            <see cref="F:UnityEngine.AnimatorUpdateMode.AnimatePhysics"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable.LayerList">
            <summary>
            A list of <see cref="T:Animancer.AnimancerLayer"/>s with methods to control their mixing and masking.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList._Layers">
            <summary>[Internal] The layers which each manage their own set of animations.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList.LayerMixer">
            <summary>The <see cref="T:UnityEngine.Animations.AnimationLayerMixerPlayable"/> which blends the layers.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList._Count">
            <summary>The number of layers that have actually been created.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.#ctor(Animancer.AnimancerPlayable,UnityEngine.Playables.Playable@)">
            <summary>[Internal] Constructs a new <see cref="T:Animancer.AnimancerPlayable.LayerList"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.Count">
            <summary>[Pro-Only] The number of layers in this list.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value is set higher than the <see cref="P:Animancer.AnimancerPlayable.LayerList.DefaultCapacity"/>. This is simply a safety measure,
            so if you do actually need more layers you can just increase the limit.
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">The value is set to a negative number.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetMinCount(System.Int32)">
            <summary>[Pro-Only]
            If the <see cref="P:Animancer.AnimancerPlayable.LayerList.Count"/> is below the specified `min`, this method increases it to that value.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.RespectSingleLayerWeight">
            <summary>[Pro-Only]
            Sets the <see cref="T:UnityEngine.Animations.AnimationLayerMixerPlayable"/> to have at least two inputs because a Unity Bug
            (1159548) causes it to ignore the <see cref="P:Animancer.AnimancerNode.Weight"/> of the layer when there is only
            one. Usually this does not matter, however in Unity 2019.1+ it is possible to blend Animancer with
            the regular <see cref="P:UnityEngine.Animator.runtimeAnimatorController"/> field as long as it's using a Generic Rig,
            in which case the layer weight is important.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.DefaultCapacity">
            <summary>[Pro-Only]
            The maximum number of layers that can be created before an <see cref="T:System.ArgumentOutOfRangeException"/> will
            be thrown (default 4).
            <para></para>
            Lowering this value will not affect layers that have already been created.
            </summary>
            <example>
            To set this value automatically when the application starts, place the following method in any class:
            <code>[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
            private static void SetMaxLayerCount()
            {
                Animancer.AnimancerPlayable.LayerList.defaultCapacity = 8;
            }</code>
            Otherwise you can set the <see cref="P:Animancer.AnimancerPlayable.LayerList.Capacity"/> of each individual list:
            <code>AnimancerComponent animancer;
            animancer.Layers.Capacity = 8;</code>
            </example>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetMinDefaultCapacity(System.Int32)">
            <summary>[Pro-Only]
            If the <see cref="P:Animancer.AnimancerPlayable.LayerList.DefaultCapacity"/> is below the specified `min`, this method increases it to that value.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.Capacity">
            <summary>[Pro-Only]
            The maximum number of layers that can be created before an <see cref="T:System.ArgumentOutOfRangeException"/> will
            be thrown. The initial capacity is determined by <see cref="P:Animancer.AnimancerPlayable.LayerList.DefaultCapacity"/>.
            <para></para>
            Lowering this value will destroy any layers beyond the specified value.
            <para></para>
            Any changes to this value after a layer has been created will cause the allocation of a new array and
            garbage collection of the old one, so you should generally set it during initialisation.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The value is not greater than 0.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.Add">
            <summary>[Pro-Only]
            Creates and returns a new <see cref="T:Animancer.AnimancerLayer"/>. New layers will override earlier layers by default.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value is set higher than the <see cref="P:Animancer.AnimancerPlayable.LayerList.Capacity"/>. This is simply a safety measure,
            so if you do actually need more layers you can just increase the limit.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.Item(System.Int32)">
            <summary>
            Returns the layer at the specified index. If it didn't already exist, this method creates it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.GetEnumerator">
            <summary>Returns an enumerator that will iterate through all layers.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that will iterate through all layers.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.GetAllStateEnumerable">
            <summary>
            Returns an enumerator that will iterate through all states in each layer (not states inside mixers).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in all layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.IsAdditive(System.Int32)">
            <summary>[Pro-Only]
            Checks whether the layer at the specified index is set to additive blending. Otherwise it will override any
            earlier layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetAdditive(System.Int32,System.Boolean)">
            <summary>[Pro-Only]
            Sets the layer at the specified index to blend additively with earlier layers (if true) or to override them
            (if false). Newly created layers will override by default.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetMask(System.Int32,UnityEngine.AvatarMask)">
            <summary>[Pro-Only]
            Sets an <see cref="T:UnityEngine.AvatarMask"/> to determine which bones the layer at the specified index will affect.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetName(System.Int32,System.String)">
            <summary>[Editor-Conditional]
            Sets the Inspector display name of the layer at the specified index. Note that layer names are Editor-Only
            so any calls to this method will automatically be compiled out of a runtime build.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.AverageVelocity">
            <summary>
            The average velocity of the root motion of all currently playing animations, taking their current
            <see cref="P:Animancer.AnimancerNode.Weight"/> into account.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetWeightlessChildrenConnected(System.Boolean)">
            <summary>[Internal]
            Connects or disconnects all children from their parent <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable.StateDictionary">
            <summary>
            A dictionary of <see cref="T:Animancer.AnimancerState"/>s mapped to their <see cref="P:Animancer.AnimancerState.Key"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.StateDictionary.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.ReferenceKeysOnly">
            <summary>
            Determines the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> used by every new <see cref="T:Animancer.AnimancerPlayable.StateDictionary"/> when
            it is created. Changing this value will not affect existing instances.
            <list type="bullet">
            <item>The default is false, which will use a <see cref="T:Animancer.FastComparer"/>.</item>
            <item>Setting it to true will use a <see cref="T:Animancer.FastReferenceComparer"/>, which is faster but does not
            work for value types such as enums because it uses <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.</item>
            </list>
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.StateDictionary.States">
            <summary><see cref="P:Animancer.AnimancerState.Key"/> mapped to <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.#ctor(Animancer.AnimancerPlayable)">
            <summary>[Internal] Constructs a new <see cref="T:Animancer.AnimancerPlayable.StateDictionary"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Count">
            <summary>The number of states that have been registered with a <see cref="P:Animancer.AnimancerState.Key"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Create(UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip`.
            <para></para>
            To create a state on a different layer, call <c>animancer.Layers[x].CreateState(clip)</c> instead.
            </summary>
            <remarks>
            <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> is used to determine the <see cref="P:Animancer.AnimancerState.Key"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Create(System.Object,UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` and registers it with the `key`.
            <para></para>
            To create a state on a different layer, call <c>animancer.Layers[x].CreateState(key, clip)</c> instead.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Create``1">
            <summary>
            Creates and returns a new <typeparamref name="T"/>.
            <para></para>
            To create it on a different layer, call <c>animancer.Layers[x].CreateState&lt;T&gt;()</c> instead.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.CreateIfNew(UnityEngine.AnimationClip[])">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified `clips`.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Current">
            <summary>
            The <see cref="P:Animancer.AnimancerLayer.CurrentState"/> on layer 0.
            <para></para>
            Specifically, this is the state that was most recently started using any of the Play methods on that layer.
            States controlled individually via methods in the <see cref="T:Animancer.AnimancerState"/> itself will not register in
            this property.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(UnityEngine.AnimationClip)">
            <summary>Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> then returns the state registered with that key.</summary>
            <exception cref="T:System.ArgumentNullException">The key is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No state is registered with the key.</exception>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(Animancer.IHasKey)">
            <summary>Returns the state registered with the <see cref="P:Animancer.IHasKey.Key"/>.</summary>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No state is registered with the `key`.</exception>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(System.Object)">
            <summary>Returns the state registered with the `key`.</summary>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No state is registered with the `key`.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(UnityEngine.AnimationClip,Animancer.AnimancerState@)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> then passes the key to
            <see cref="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(System.Object,Animancer.AnimancerState@)"/> and returns the result.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(Animancer.IHasKey,Animancer.AnimancerState@)">
            <summary>
            Passes the <see cref="P:Animancer.IHasKey.Key"/> into <see cref="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(System.Object,Animancer.AnimancerState@)"/>
            and returns the result.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(System.Object,Animancer.AnimancerState@)">
            <summary>
            If a state is registered with the `key`, this method outputs it as the `state` and returns true. Otherwise
            `state` is set to null and this method returns false.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> and returns the state which registered with that key or creates one if it
            doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(Animancer.ITransition)">
            <summary>
            Returns the state registered with the `transition`s <see cref="P:Animancer.IHasKey.Key"/> if there is one. Otherwise
            this method uses <see cref="M:Animancer.ITransition.CreateState"/> to create a new one and registers it with
            that key before returning it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(System.Object,UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Returns the state which registered with the `key` or creates one if it doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            </summary>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
            <remarks>See also: <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(System.Object,UnityEngine.AnimationClip,System.Boolean)"/></remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetClipMismatchError(System.Object,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>Returns an error message explaining that a state already exists with the specified `key`.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Register(System.Object,Animancer.AnimancerState)">
            <summary>[Internal]
            Registers the `state` in this dictionary so the `key` can be used to get it later on using
            <see cref="P:Animancer.AnimancerPlayable.StateDictionary.Item(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Unregister(Animancer.AnimancerState)">
            <summary>[Internal]
            Removes the `state` from this dictionary.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetEnumerator">
            <summary>
            Returns an enumerator that will iterate through all states in each layer (not states inside mixers).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in all layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Destroy"/> on the state associated with the `clip` (if any).
            Returns true if the state existed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(Animancer.IHasKey)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Destroy"/> on the state associated with the <see cref="P:Animancer.IHasKey.Key"/>
            (if any). Returns true if the state existed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(System.Object)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Destroy"/> on the state associated with the `key` (if any).
            Returns true if the state existed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(System.Collections.Generic.IList{UnityEngine.AnimationClip})">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on each of the `clips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(System.Collections.Generic.IEnumerable{UnityEngine.AnimationClip})">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on each of the `clips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(UnityEngine.IAnimationClipSource)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on all states gathered by
            <see cref="M:UnityEngine.IAnimationClipSource.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(Animancer.IAnimationClipCollection)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on all states gathered by
            <see cref="M:Animancer.IAnimationClipCollection.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll">
            <summary>
            Destroys all states connected to all layers (regardless of whether they are actually registered in this
            dictionary).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            The whole point of a key is to identify a state in the first place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(Animancer.AnimancerState,Animancer.AnimancerState@)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            The whole point of a key is to identify a state in the first place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(Animancer.AnimancerState,UnityEngine.AnimationClip)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            The whole point of a key is to identify a state in the first place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            Just call <see cref="M:Animancer.AnimancerState.Destroy"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerState">
            <summary>
            Base class for all states in an <see cref="T:Animancer.AnimancerPlayable"/> graph.
            Each state is a wrapper for a <see cref="T:UnityEngine.Playables.Playable"/> in the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            <para></para>
            This class can be used as a custom yield instruction to wait until the animation either stops playing or reaches its end.
            </summary>
            <remarks>
            There are various different ways of getting a state:
            <list type="bullet">
              <item>
              Use one of the state's constructors. Generally the first parameter is a layer or mixer which will be used as
              the state's parent. If not specified, you will need to call SetParent manually. Also note than an
              AnimancerComponent can be implicitly cast to its first layer.
              </item>
              <item>
              AnimancerController.CreateState creates a new ClipState. You can optionally specify a custom `key` to
              register it in the dictionary instead of the default (the `clip` itself).
              </item>
              <item>
              AnimancerController.GetOrCreateState looks for an existing state registered with the specified `key` and only
              creates a new one if it doesn’t already exist.
              </item>
              <item>
              AnimancerController.GetState returns an existing state registered with the specified `key` if there is one.
              </item>
              <item>
              AnimancerController.TryGetState is similar but returns a bool to indicate success and returns the `state`
              as an out parameter.
              </item>
              <item>
              AnimancerController.Play and CrossFade also return the state they play.
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.SetRoot(Animancer.AnimancerPlayable)">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.Parent">
            <summary>The object which receives the output of the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Connects this state to the `parent` mixer at the specified `index`.
            <para></para>
            See also <see cref="M:Animancer.AnimancerLayer.AddChild(Animancer.AnimancerState)"/> to connect a state to an available port on a
            layer.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.ClearParent">
            <summary>[Internal]
            Called by <see cref="M:Animancer.AnimancerNode.OnAddChild(System.Collections.Generic.IList{Animancer.AnimancerState},Animancer.AnimancerState)"/> if the specified
            port is already occupied so it can be cleared without triggering any other calls.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.EffectiveWeight">
            <summary>
            The <see cref="P:Animancer.AnimancerNode.Weight"/> of this state multiplied by the <see cref="P:Animancer.AnimancerNode.Weight"/> of each of
            its parents down the hierarchy to determine how much this state affects the final output.
            </summary>
            <exception cref="T:System.NullReferenceException">This state has no <see cref="P:Animancer.AnimancerNode.Parent"/>.</exception>
        </member>
        <member name="P:Animancer.AnimancerState.Layer">
            <summary>The root <see cref="T:Animancer.AnimancerLayer"/> which this state is connected to.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.LayerIndex">
            <summary>
            The index of the <see cref="T:Animancer.AnimancerLayer"/> this state is connected to (determined by the
            <see cref="P:Animancer.AnimancerState.Parent"/>).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Key">
            <summary>
            The object used to identify this state in the root <see cref="P:Animancer.AnimancerPlayable.States"/> dictionary.
            Can be null.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays (if any).</summary>
            <exception cref="T:System.NotSupportedException">
            This state type doesn't have a clip and you try to set it.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerState.MainObject">
            <summary>The main object to show in the Inspector for this state (if any).</summary>
            <exception cref="T:System.NotSupportedException">
            This state type doesn't have a main object and you try to set it.
            </exception>
            <exception cref="T:System.InvalidCastException">This state can't use the assigned value.</exception>
        </member>
        <member name="M:Animancer.AnimancerState.ChangeMainObject``1(``0@,``0)">
            <summary>
            Sets the `currentObject` and calls <see cref="M:Animancer.AnimancerNode.RecreatePlayable"/>. If the `currentObject` was
            being used as the <see cref="P:Animancer.AnimancerState.Key"/> then it is changed as well.
            </summary>
            <exception cref="T:System.ArgumentNullException">The `newObject` is null.</exception>
        </member>
        <member name="P:Animancer.AnimancerState.AverageVelocity">
            <summary>The average velocity of the root motion caused by this state.</summary>
        </member>
        <member name="F:Animancer.AnimancerState._IsPlaying">
            <summary>Is the <see cref="P:Animancer.AnimancerState.Time"/> automatically advancing?</summary>
        </member>
        <member name="F:Animancer.AnimancerState._IsPlayingDirty">
            <summary>
            Has <see cref="F:Animancer.AnimancerState._IsPlaying"/> changed since it was last applied to the <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
            <remarks>
            Playables start playing by default so we start dirty to pause it during the first update (unless
            <see cref="P:Animancer.AnimancerState.IsPlaying"/> is set to true before that).
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.IsPlaying">
             <summary>Is the <see cref="P:Animancer.AnimancerState.Time"/> automatically advancing?</summary>
            
             <example>
             <code>
             void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.States.GetOrCreate(clip);
            
                 if (state.IsPlaying)
                     Debug.Log(clip + " is playing");
                 else
                     Debug.Log(clip + " is paused");
            
                 state.IsPlaying = false;// Pause the animation.
            
                 state.IsPlaying = true;// Unpause the animation.
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerState.IsActive">
            <summary>
            Returns true if this state is playing and is at or fading towards a non-zero
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.IsStopped">
            <summary>
            Returns true if this state is not playing and is at 0 <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Play">
            <summary>
            Plays this animation immediately, without any blending.
            Sets <see cref="P:Animancer.AnimancerState.IsPlaying"/> = true, <see cref="P:Animancer.AnimancerNode.Weight"/> = 1, and clears the
            <see cref="P:Animancer.AnimancerState.Events"/>.
            <para></para>
            This method does not change the <see cref="P:Animancer.AnimancerState.Time"/> so it will continue from its current value.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Stop">
            <summary>
            Stops the animation and makes it inactive immediately so it no longer affects the output.
            Sets <see cref="P:Animancer.AnimancerNode.Weight"/> = 0, <see cref="P:Animancer.AnimancerState.IsPlaying"/> = false, <see cref="P:Animancer.AnimancerState.Time"/> = 0, and
            clears the <see cref="P:Animancer.AnimancerState.Events"/>.
            <para></para>
            If you only want to freeze the animation in place, you can set <see cref="P:Animancer.AnimancerState.IsPlaying"/> = false instead. Or
            to freeze all animations, you can call <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.OnStartFade">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/>. Clears the <see cref="P:Animancer.AnimancerState.Events"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerState._Time">
            <summary>
            The current time of the <see cref="T:UnityEngine.Playables.Playable"/>, retrieved by <see cref="P:Animancer.AnimancerState.Time"/> whenever the
            <see cref="F:Animancer.AnimancerState._TimeFrameID"/> is different from the <see cref="P:Animancer.AnimancerPlayable.FrameID"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerState._MustSetTime">
            <summary>
            Indicates whether the <see cref="F:Animancer.AnimancerState._Time"/> needs to be assigned to the <see cref="T:UnityEngine.Playables.Playable"/> next update.
            </summary>
            <remarks>
            <see cref="T:Animancer.AnimancerState.EventRunner"/> executes after all other playables, at which point changes can still be made to
            their time but not their weight which means that if we set the time immediately then it can be out of sync
            with the weight. For example, if an animation ends and you play another, the first animation would be
            stopped and rewinded to the start but would still be at full weight so it would show its first frame before
            the new animation actually takes effect (even if the previous animation was not looping).
            <para></para>
            So instead, we simply delay setting the actual playable time until the next update so that time and weight
            are always in sync.
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerState._TimeFrameID">
            <summary>
            The <see cref="P:Animancer.AnimancerPlayable.FrameID"/> from when the <see cref="P:Animancer.AnimancerState.Time"/> was last retrieved from the
            <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Time">
             <summary>
             The number of seconds that have passed since the start of this animation.
             <para></para>
             This value will continue increasing after the animation passes the end of its <see cref="P:Animancer.AnimancerState.Length"/> while
             the animated object either freezes in place or starts again from the beginning according to whether it is
             looping or not.
             <para></para>
             Animancer Lite does not allow this value to be changed in a runtime build (except resetting it to 0).
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 // Skip 0.5 seconds into the animation:
                 state.Time = 0.5f;
            
                 // Skip 50% of the way through the animation (0.5 in a range of 0 to 1):
                 state.NormalizedTime = 0.5f;
            
                 // Skip to the end of the animation and play backwards.
                 state.NormalizedTime = 1;
                 state.Speed = -1;
             }
             </code>
             </example>
            
             <remarks>
             This property internally uses <see cref="P:Animancer.AnimancerState.RawTime"/> whenever the value is out of date or gets changed.
             </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.RawTime">
            <summary>
            The internal implementation of <see cref="P:Animancer.AnimancerState.Time"/> which directly gets and sets the underlying value.
            </summary>
            <remarks>
            Setting this value actually calls <see cref="M:UnityEngine.Playables.PlayableExtensions.SetTime``1(``0,System.Double)"/> twice to ensure that animation
            events aren't triggered incorrectly. Calling it only once would trigger any animation events between the
            previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as
            by calling <see cref="M:Animancer.AnimancerState.Stop"/> or playing a different animation), the next time that animation played it
            would immediately trigger all of its events, then play through and trigger them normally as well.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.NormalizedTime">
             <summary>
             The <see cref="P:Animancer.AnimancerState.Time"/> of this state as a portion of the animation's <see cref="P:Animancer.AnimancerState.Length"/>, meaning the
             value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes.
             <para></para>
             This value will continue increasing after the animation passes the end of its <see cref="P:Animancer.AnimancerState.Length"/> while
             the animated object either freezes in place or starts again from the beginning according to whether it is
             looping or not.
             <para></para>
             The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the
             current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has
             been looped.
             <para></para>
             Animancer Lite does not allow this value to be changed to a value other than 0 in a runtime build.
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 // Skip 0.5 seconds into the animation:
                 state.Time = 0.5f;
            
                 // Skip 50% of the way through the animation (0.5 in a range of 0 to 1):
                 state.NormalizedTime = 0.5f;
            
                 // Skip to the end of the animation and play backwards.
                 state.NormalizedTime = 1;
                 state.Speed = -1;
             }
             </code>
             </example>
        </member>
        <member name="M:Animancer.AnimancerState.CancelSetTime">
            <summary>Prevents the <see cref="P:Animancer.AnimancerState.RawTime"/> from being applied.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.Duration">
             <summary>
             The number of seconds the animation will take to play fully at its current
             <see cref="P:Animancer.AnimancerNode.Speed"/>.
             <para></para>
             Setting this value modifies the <see cref="P:Animancer.AnimancerNode.Speed"/>, not the <see cref="P:Animancer.AnimancerState.Length"/>.
             Animancer Lite does not allow this value to be changed in a runtime build.
             <para></para>
             For the time remaining from now until it reaches the end, use <see cref="P:Animancer.AnimancerState.RemainingDuration"/> instead.
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.Duration = 1;// Play fully in 1 second.
                 state.Duration = 2;// Play fully in 2 seconds.
                 state.Duration = 0.5f;// Play fully in half a second.
                 state.Duration = -1;// Play backwards fully in 1 second.
                 state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second.
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerState.RemainingDuration">
             <summary>
             The number of seconds the animation will take to reach the end at its current <see cref="P:Animancer.AnimancerNode.Speed"/>.
             <para></para>
             Setting this value modifies the <see cref="P:Animancer.AnimancerNode.Speed"/>, not the <see cref="P:Animancer.AnimancerState.Length"/>.
             Animancer Lite does not allow this value to be changed in a runtime build.
             <para></para>
             For the time it would take to play fully from the start, use <see cref="P:Animancer.AnimancerState.Duration"/> instead.
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.RemainingDuration = 1;// Play from the current time to the end in 1 second.
                 state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds.
                 state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second.
                 state.RemainingDuration = -1;// Play backwards from the current time to the end in 1 second.
             }
             </code>
             </example>
        </member>
        <member name="P:Animancer.AnimancerState.Length">
            <summary>The total time this state takes to play in seconds (when <c>Speed = 1</c>).</summary>
        </member>
        <member name="P:Animancer.AnimancerState.IsLooping">
            <summary>
            Indicates whether this state will loop back to the start when it reaches the end.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Update(System.Boolean@)">
            <summary>
            Updates the <see cref="P:Animancer.AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent
            mixer, and plays or pauses the <see cref="T:UnityEngine.Playables.Playable"/> if its state is dirty.
            <para></para>
            If the <see cref="P:Animancer.AnimancerState.Parent"/>'s <see cref="P:Animancer.AnimancerNode.KeepChildrenConnected"/> is set to false, this
            method will also connect/disconnect this node from the <see cref="P:Animancer.AnimancerState.Parent"/> in the playable graph.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Destroy">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/> and cleans up this state.</summary>
            <remarks>
            This method is NOT called automatically, so when implementing a custom state type you must use
            <see cref="P:Animancer.AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in this state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.IsPlayingAndNotEnding">
            <summary>
            Returns true if the animation is playing and has not yet passed the
            <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/>.
            <para></para>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.ToString">
            <summary>
            Returns the <see cref="P:Animancer.AnimancerNode.Name"/> if one is set, otherwise a string describing the type of this
            state and the name of the <see cref="P:Animancer.AnimancerState.MainObject"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.CreateDrawer">
            <summary>[Editor-Only] Returns a custom drawer for this state.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)"/> to append the details of this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.GetPath">
            <summary>Returns the hierarchy path of this state through its <see cref="P:Animancer.AnimancerState.Parent"/>s.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendPath(System.Text.StringBuilder,Animancer.AnimancerNode)">
            <summary>Appends the hierarchy path of this state through its <see cref="P:Animancer.AnimancerState.Parent"/>s.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendPortAndType(System.Text.StringBuilder)">
            <summary>Appends "[Index] -> GetType().Name".</summary>
        </member>
        <member name="T:Animancer.AnimancerState.Transition`1">
            <summary>
            Base class for serializable <see cref="T:Animancer.ITransition"/>s which can create a particular type of
            <see cref="T:Animancer.AnimancerState"/> when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            <para></para>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.FadeDuration">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The amount of time the transition will take (in seconds).</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.IsLooping">
            <summary>[<see cref="T:Animancer.ITransitionDetailed"/>]
            Indicates what the value of <see cref="P:Animancer.AnimancerState.IsLooping"/> will be for the created state.
            Returns false unless overridden.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.NormalizedStartTime">
            <summary>[<see cref="T:Animancer.ITransitionDetailed"/>]
            Determines what <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to start the animation at.
            Returns <see cref="F:System.Single.NaN"/> unless overridden.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.Speed">
            <summary>[<see cref="T:Animancer.ITransitionDetailed"/>]
            Determines how fast the animation plays (1x = normal speed).
            Returns 1 unless overridden.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.MaximumDuration">
            <summary>[<see cref="T:Animancer.ITransitionDetailed"/>]
            The maximum amount of time the animation is expected to take (in seconds).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.Events">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] Events which will be triggered as the animation plays.</summary>
            <remarks>This property returns the <see cref="P:Animancer.AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.SerializedEvents">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] Events which will be triggered as the animation plays.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.BaseState">
            <summary>
            The state that was created by this object. Specifically, this is the state that was most recently
            passed into <see cref="M:Animancer.AnimancerState.Transition`1.Apply(Animancer.AnimancerState)"/> (usually by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>).
            <para></para>
            You can use <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(Animancer.ITransition)"/> or
            <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(Animancer.ITransition)"/> to get or create the state for a
            specific object.
            <para></para>
            <see cref="P:Animancer.AnimancerState.Transition`1.State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.State">
            <summary>
            The state that was created by this object. Specifically, this is the state that was most recently
            passed into <see cref="M:Animancer.AnimancerState.Transition`1.Apply(Animancer.AnimancerState)"/> (usually by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>).
            <para></para>
            You can use <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(Animancer.ITransition)"/> or
            <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(Animancer.ITransition)"/> to get or create the state for a
            specific object.
            <para></para>
            This property is shorthand for casting the <see cref="P:Animancer.AnimancerState.Transition`1.BaseState"/> to <typeparamref name="TState"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">
            The <see cref="P:Animancer.AnimancerState.Transition`1.BaseState"/> is not actually a <typeparamref name="TState"/>. This should only
            happen if a different type of state was created by something else and registered using the
            <see cref="P:Animancer.AnimancerState.Transition`1.Key"/>, causing this <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> to pass that
            state into <see cref="M:Animancer.AnimancerState.Transition`1.Apply(Animancer.AnimancerState)"/> instead of calling <see cref="M:Animancer.AnimancerState.Transition`1.CreateState"/> to make the correct type of
            state.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.IsValid">
            <summary>Indicates whether this transition can create a valid <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.Key">
            <summary>
            The <see cref="P:Animancer.AnimancerState.Key"/> which the created state will be registered with.
            <para></para>
            By default, a transition is used as its own <see cref="P:Animancer.AnimancerState.Transition`1.Key"/>, but this property can be overridden.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Transition`1.FadeMode">
            <summary>
            When a transition is passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>, this property
            determines which <see cref="T:Animancer.FadeMode"/> will be used.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Transition`1.CreateState">
            <summary>
            Creates and returns a new <typeparamref name="TState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.AnimancerState.Transition`1.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method as well.
            Or you can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Transition`1.Animancer#ITransition#CreateState">
            <summary>
            Creates and returns a new <typeparamref name="TState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.AnimancerState.Transition`1.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method as well. Or you
            can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Transition`1.Apply(Animancer.AnimancerState)">
            <summary>[<see cref="T:Animancer.ITransition"/>]
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> to set the <see cref="P:Animancer.AnimancerState.Transition`1.BaseState"/>
            and apply any other modifications to the `state`.
            </summary>
            <remarks>
            This method also clears the <see cref="P:Animancer.AnimancerState.Transition`1.State"/> if necessary, so it will re-cast the
            <see cref="P:Animancer.AnimancerState.Transition`1.BaseState"/> when it gets accessed again.
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerState.Transition`1.NestedObjectDrawers">
            <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Transition`1.Animancer#ITransitionDetailed#AddItemsToContextMenu(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,Animancer.Editor.Serialization.PropertyAccessor)">
            <summary>[Editor-Only] Adds context menu functions for this transition.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Transition`1.AddItemsToContextMenu(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,Animancer.Editor.Serialization.PropertyAccessor)">
            <summary>[Editor-Only] Adds context menu functions for this transition.</summary>
        </member>
        <member name="F:Animancer.AnimancerState._EventRunner">
            <summary>
            The <see cref="T:Animancer.IUpdatable"/> that manages the events of this state.
            <para></para>
            This field is null by default, acquires its reference from an <see cref="T:Animancer.ObjectPool"/> when accessed, and
            if it contains no events at the end of an update it releases the reference back to the pool.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Events">
            <summary>
            A list of <see cref="T:Animancer.AnimancerEvent"/>s that will occur while this state plays as well as one that
            specifically defines when this state ends.
            <para></para>
            Accessing this property will acquire a spare <see cref="T:Animancer.AnimancerEvent.Sequence"/> from the
            <see cref="T:Animancer.ObjectPool"/> if none was already assigned. You can use <see cref="P:Animancer.AnimancerState.HasEvents"/> to check
            beforehand.
            <para></para>
            Animancer Lite does not allow the use of events in a runtime build, except for
            <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.HasEvents">
            <summary>
            Indicates whether this state currently has an <see cref="T:Animancer.AnimancerEvent.Sequence"/> (since accessing the
            <see cref="P:Animancer.AnimancerState.Events"/> would automatically get one from the <see cref="T:Animancer.ObjectPool"/>).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.UnsupportedEventsMessage">
            <summary>[Assert-Only]
            Returns null if Animancer Events will work properly on this type of state, or a message explaining why they
            might not work.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.EventPoolCapacity">
            <summary>
            The capacity of the internal list in the <see cref="T:Animancer.ObjectPool`1"/> for <see cref="T:Animancer.AnimancerState.EventRunner"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.EventPoolCount">
            <summary>
            The number of spare items in the <see cref="T:Animancer.ObjectPool`1"/> for <see cref="T:Animancer.AnimancerState.EventRunner"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.SetMinEventPoolCount(System.Int32)">
            <summary>
            If the <see cref="P:Animancer.AnimancerState.EventPoolCount"/> is less than the specified value, this method increases it to that
            value by creating new objects.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerState.EventRunner">
            <summary>
            An <see cref="T:Animancer.IUpdatable"/> which manages the triggering of events.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventRunner.Acquire(Animancer.AnimancerState)">
            <summary>
            If the `state` has no <see cref="T:Animancer.AnimancerState.EventRunner"/>, this method gets one from the
            <see cref="T:Animancer.ObjectPool"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventRunner.Release">
            <summary>
            Returns this <see cref="T:Animancer.AnimancerState.EventRunner"/> to the <see cref="T:Animancer.ObjectPool"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventRunner.TryClear(Animancer.AnimancerState.EventRunner)">
            <summary>
            If the <see cref="T:Animancer.AnimancerEvent.Sequence"/> was acquired from the <see cref="T:Animancer.ObjectPool"/>, this
            method clears it. Otherwise it simply discards the reference.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerState.EventRunner.SequenceVersionException">
            <summary>
            This system accounts for external modifications to the sequence, but modifying it while checking which
            of its events to update is not allowed because it would be impossible to efficiently keep track of
            which events have been checked/invoked and which still need to be checked.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventRunner.ValidateEndCallback(System.Action)">
            <summary>[Assert-Conditional]
            Called after the <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/> is triggered to log a warning if the
            <see cref="F:Animancer.AnimancerState.EventRunner._State"/> was not interrupted or the `callback` contains multiple calls to the same method.
            </summary>
            <remarks>
            It would be better if we could validate the callback when it is assigned to get a useful stack trace,
            but that is unfortunately not possible since <see cref="F:Animancer.AnimancerEvent.Sequence.endEvent"/> needs to be
            a field for efficiency.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.EventRunner.UpdateZeroLength">
            <summary>If the state has zero length, trigger its end event every frame.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventRunner.ToString">
            <summary>Returns "EventRunner (Target State)".</summary>
        </member>
        <member name="T:Animancer.AnimancerUtilities">
            <summary>Various extension methods and utilities.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Wrap01(System.Single)">
            <summary>[Animancer Extension] Loops the `value` so that <c>0 &lt;= value &lt; 1</c>.</summary>
            <remarks>This is more efficient than using <see cref="M:UnityEngine.Mathf.Repeat(System.Single,System.Single)"/> with a length of 1.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IsFinite(System.Single)">
            <summary>[Animancer Extension] Returns true as long as the `value` is not NaN or Infinity.</summary>
            <remarks>Newer versions of the .NET framework apparently have a <c>float.IsFinite</c> method.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.ToStringOrNull(System.Object)">
            <summary>
            If `obj` exists, this method returns <see cref="M:System.Object.ToString"/>.
            Or if it is null, this method returns "null".
            Or if it is an <see cref="T:UnityEngine.Object"/> that has been destroyed, this method returns "Null (ObjectType)".
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Swap``1(``0[],System.Int32,System.Int32)">
            <summary>[Animancer Extension] Swaps <c>array[a]</c> with <c>array[b]</c>.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.AddAnimancerComponent``1(UnityEngine.Animator)">
            <summary>[Animancer Extension]
            Adds the specified type of <see cref="T:Animancer.IAnimancerComponent"/>, links it to the `animator`, and returns it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetOrAddAnimancerComponent``1(UnityEngine.Animator)">
            <summary>[Animancer Extension]
            Returns the <see cref="T:Animancer.IAnimancerComponent"/> on the same <see cref="T:UnityEngine.GameObject"/> as the `animator` if
            there is one. Otherwise this method adds a new one and returns it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IsValid(Animancer.AnimancerNode)">
            <summary>Returns true if the `node` is not null and <see cref="P:Animancer.AnimancerNode.IsValid"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IsValid(Animancer.ITransitionDetailed)">
            <summary>Returns true if the `node` is not null and <see cref="P:Animancer.ITransitionDetailed.IsValid"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)">
            <summary>Calls <see cref="M:Animancer.ITransition.CreateState"/> and <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CreateNativeReference``1">
            <summary>
            Creates a <see cref="T:Unity.Collections.NativeArray`1"/> containing a single element so that it can be used like a reference
            in Unity's C# Job system which does not allow regular reference types.
            <para></para>
            Note that you must call <see cref="M:Unity.Collections.NativeArray`1.Dispose"/> when you are done with the array.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.RemovePlayable(UnityEngine.Playables.Playable,System.Boolean)">
            <summary>[Pro-Only]
            Reconnects the input of the specified `playable` to its output.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.HasEvent(Animancer.IAnimationClipCollection,System.String)">
            <summary>
            Checks if any <see cref="T:UnityEngine.AnimationClip"/> in the `source` has an animation event with the specified
            `functionName`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.HasEvent(UnityEngine.AnimationClip,System.String)">
            <summary>Checks if the `clip` has an animation event with the specified `functionName`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CalculateThresholdsFromAverageVelocityXZ(Animancer.MixerState{UnityEngine.Vector2})">
            <summary>[Pro-Only]
            Calculates all thresholds in the `mixer` using the <see cref="P:Animancer.AnimancerState.AverageVelocity"/> of each
            state on the X and Z axes.
            <para></para>
            Note that this method requires the <c>Root Transform Position (XZ) -> Bake Into Pose</c> toggle to be
            disabled in the Import Settings of each <see cref="T:UnityEngine.AnimationClip"/> in the mixer.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetParameterValue(UnityEngine.Animator,UnityEngine.AnimatorControllerParameter)">
            <summary>Gets the value of the `parameter` in the `animator`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetParameterValue(UnityEngine.Animations.AnimatorControllerPlayable,UnityEngine.AnimatorControllerParameter)">
            <summary>Gets the value of the `parameter` in the `playable`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.SetParameterValue(UnityEngine.Animator,UnityEngine.AnimatorControllerParameter,System.Object)">
            <summary>Sets the `value` of the `parameter` in the `animator`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.SetParameterValue(UnityEngine.Animations.AnimatorControllerPlayable,UnityEngine.AnimatorControllerParameter,System.Object)">
            <summary>Sets the `value` of the `parameter` in the `playable`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.SetDirty(UnityEngine.Object)">
            <summary>[Editor-Conditional] Indicates that the `target` needs to be re-serialized.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IfMultiComponentThenChangeType``1(``0)">
            <summary>[Editor-Conditional]
            If there are multiple components which inherit from <typeparamref name="T"/>, the first one is changed to
            the type of the second and any after the first are destroyed. This allows you to change the type without
            losing the values of any serialized fields they share.
            <para></para>
            The `currentComponent` is used to determine which <see cref="T:UnityEngine.GameObject"/> to examine and the base
            component type <typeparamref name="T"/>.
            </summary>
            <example><code>
            protected void Reset()
            {
                AnimancerUtilities.IfMultiComponentThenChangeType(this);
            }
            </code></example>
        </member>
        <member name="M:Animancer.AnimancerUtilities.EditModePlay(Animancer.IAnimancerComponent,UnityEngine.AnimationClip,System.Boolean)">
            <summary>[Editor-Conditional]
            Plays the specified `clip` if called in Edit Mode and optionally pauses it immediately.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)">
            <summary>[Animancer Extension]
            Adds the `clip` to the `clips` if it wasn't there already.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Collections.Generic.IList{UnityEngine.AnimationClip})">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each of the `newClips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Collections.Generic.IEnumerable{UnityEngine.AnimationClip})">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each of the `newClips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromAsset(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.Playables.PlayableAsset)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each clip in the `asset`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherAnimationClips(System.Collections.IEnumerable,System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Gathers all the animations in the `tracks`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromSource(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.IAnimationClipSource)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each clip gathered by
            <see cref="M:UnityEngine.IAnimationClipSource.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromSource(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Object)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each clip in the `source`,
            supporting both <see cref="T:UnityEngine.IAnimationClipSource"/> and <see cref="T:Animancer.IAnimationClipCollection"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromSources(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Collections.IList)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.GatherFromSource(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Object)"/> for each of the `sources`.
            </summary>
        </member>
        <member name="T:Animancer.ClipState">
            <summary>
            An <see cref="T:Animancer.AnimancerState"/> which plays an <see cref="T:UnityEngine.AnimationClip"/>.
            </summary>
        </member>
        <member name="F:Animancer.ClipState._Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.MainObject">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.Length">
            <summary>The <see cref="P:UnityEngine.AnimationClip.length"/>.</summary>
        </member>
        <member name="P:Animancer.ClipState.IsLooping">
            <summary>The <see cref="P:UnityEngine.Motion.isLooping"/>.</summary>
        </member>
        <member name="P:Animancer.ClipState.AverageVelocity">
            <summary>The average velocity of the root motion caused by this state.</summary>
        </member>
        <member name="P:Animancer.ClipState.ApplyAnimatorIK">
            <summary>[<see cref="T:Animancer.IHasIK"/>]
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object.
            The initial value is determined by <see cref="P:Animancer.AnimancerPlayable.DefaultApplyAnimatorIK"/>.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers.
            <para></para>
            Note that this property only applies to <see cref="T:Animancer.ClipState"/>s.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.ApplyFootIK">
            <summary>[<see cref="T:Animancer.IHasIK"/>]
            Indicates whether this state is applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerPlayable.DefaultApplyFootIK"/>.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.#ctor(UnityEngine.AnimationClip)">
            <summary>Creates a new <see cref="T:Animancer.ClipState"/> and sets its <see cref="P:Animancer.ClipState.Clip"/>.</summary>
            <exception cref="T:System.ArgumentNullException">The `clip` is null.</exception>
        </member>
        <member name="M:Animancer.ClipState.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Playables.Playable"/> managed by this node.</summary>
        </member>
        <member name="M:Animancer.ClipState.Destroy">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/> and cleans up this state.</summary>
            <remarks>
            This method is NOT called automatically, so when implementing a custom state type you must use
            <see cref="P:Animancer.AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up.
            </remarks>
        </member>
        <member name="M:Animancer.ClipState.CreateDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.ClipState.Drawer"/> for this state.</summary>
        </member>
        <member name="T:Animancer.ClipState.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.ClipState"/>.</summary>
        </member>
        <member name="M:Animancer.ClipState.Drawer.#ctor(Animancer.ClipState)">
            <summary>
            Constructs a new <see cref="T:Animancer.ClipState.Drawer"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Drawer.AddContextMenuFunctions(UnityEditor.GenericMenu)">
            <summary>Adds the details of this state to the `menu`.</summary>
        </member>
        <member name="T:Animancer.ClipState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.ITransition"/> which can create a <see cref="T:Animancer.ClipState"/> when passed
            into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.ClipState.Transition.Clip">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The animation to play.</summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.Key">
            <summary>
            The <see cref="P:Animancer.ClipState.Transition.Clip"/> will be used as the <see cref="P:Animancer.AnimancerState.Key"/> for the created state to be
            registered with.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.Speed">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines how fast the animation plays (1x = normal speed, 2x = double speed).
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.NormalizedStartTime">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines what <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to start the animation at.
            <para></para>
            The default value is <see cref="F:System.Single.NaN"/> which indicates that this value is not used so the
            animation will continue from its current time.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.FadeMode">
            <summary>
            If this transition will set the <see cref="P:Animancer.AnimancerState.NormalizedTime"/>, then it needs to use
            <see cref="F:Animancer.FadeMode.FromStart"/>.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.IsLooping">
            <summary>[<see cref="T:Animancer.ITransitionDetailed"/>] Returns <see cref="P:UnityEngine.Motion.isLooping"/>.</summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.MaximumDuration">
            <summary>[<see cref="T:Animancer.ITransitionDetailed"/>]
            The maximum amount of time the animation is expected to take (in seconds).
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Transition.IsValid">
            <summary>Indicates whether this transition can create a valid <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.ClipState.Transition.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method
            as well. Or you can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Transition.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> to apply the <see cref="P:Animancer.ClipState.Transition.Speed"/>
            and <see cref="P:Animancer.ClipState.Transition.NormalizedStartTime"/>.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Transition.Animancer#IAnimationClipCollection#GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Adds the <see cref="P:Animancer.ClipState.Transition.Clip"/> to the collection.</summary>
        </member>
        <member name="T:Animancer.ClipState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.ClipState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.ClipState.Transition.Drawer.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.ClipState.Transition.Drawer"/>.</summary>
        </member>
        <member name="T:Animancer.FadeMode">
            <summary>
            Determines how <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/> works.
            </summary>
        </member>
        <member name="F:Animancer.FadeMode.FixedSpeed">
             <summary>
             Calculate the fade speed to bring the <see cref="P:Animancer.AnimancerNode.Weight"/> from 0 to 1 over the specified
             fade duration (in seconds), regardless of the actual starting weight.
             </summary>
            
             <example>
             A fade duration of 0.5 would make the fade last for 0.5 seconds, regardless of how long the animation is.
             <para></para>
             This is generally the same as <see cref="F:Animancer.FadeMode.FixedDuration"/> but differs when starting the fade from a
             non-zero <see cref="P:Animancer.AnimancerNode.Weight"/>, for example:
             <list type="bullet">
             <item>Fade Duration: 0.25</item>
             <item>To fade from 0 to 1 with either mode would get a speed of 4 and take 0.25 seconds</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedDuration"/> would get a speed of 2 and take 0.25 seconds.
             It has half the distance to cover so it goes half as fast to maintain the expected duration.</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedSpeed"/> would get a speed of 4 and take 0.125 seconds.
             It gets the same speed regardless of the distance to cover, so with less distance it completes faster.</item>
             </list>
             </example>
            
             <exception cref="T:System.InvalidOperationException">The <see cref="P:Animancer.AnimancerState.Clip"/> is null.</exception>
            
             <exception cref="T:System.ArgumentOutOfRangeException">
             More states have been created for the <see cref="P:Animancer.AnimancerState.Clip"/> than the
             <see cref="P:Animancer.AnimancerLayer.MaxStateDepth"/> allows.
             </exception>
        </member>
        <member name="F:Animancer.FadeMode.FixedDuration">
             <summary>
             Calculate the fade speed to bring the <see cref="P:Animancer.AnimancerNode.Weight"/> to the target value over the
             specified fade duration (in seconds).
             </summary>
            
             <example>
             A fade duration of 0.5 would make the fade last for 0.5 seconds, regardless of how long the animation is.
             <para></para>
             This is generally the same as <see cref="F:Animancer.FadeMode.FixedSpeed"/>, but differs when starting the fade from a
             non-zero <see cref="P:Animancer.AnimancerNode.Weight"/>:
             <list type="bullet">
             <item>Fade Duration: 0.25</item>
             <item>To fade from 0 to 1 with either mode would get a speed of 4 and take 0.25 seconds</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedDuration"/> would get a speed of 2 and take 0.25 seconds.
             It has half the distance to cover so it goes half as fast to maintain the expected duration.</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedSpeed"/> would get a speed of 4 and take 0.125 seconds.
             It gets the same speed regardless of the distance to cover, so with less distance it completes faster.</item>
             </list>
             </example>
            
             <remarks>
             This was how fading worked prior to the introduction of <see cref="T:Animancer.FadeMode"/>s in Animancer v4.0.
             </remarks>
        </member>
        <member name="F:Animancer.FadeMode.FromStart">
             <summary>
             If the state is not currently at 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this mode will use
             <see cref="M:Animancer.AnimancerLayer.GetOrCreateWeightlessState(Animancer.AnimancerState)"/> to get a copy of it that is at 0 weight so it can
             fade the copy in while the original fades out with all other states.
             <para></para>
             Using this mode repeatedly on subsequent frames will probably have undesirable effects because it will
             create a new state each time. In such a situation you most likely want <see cref="F:Animancer.FadeMode.FixedSpeed"/> instead.
             <para></para>
             This mode only works for <see cref="T:Animancer.ClipState"/>s.
             </summary>
            
             <example>
             This can be useful when you want to repeat an action while the previous animation is still fading out.
             For example, if you play an 'Attack' animation, it ends and starts fading back to 'Idle', and while it is
             doing so you want to start another 'Attack'. The previous 'Attack' can't simply snap back to the start, so
             you can use this method to create a second 'Attack' state to fade in while the old one fades out.
             </example>
        </member>
        <member name="F:Animancer.FadeMode.NormalizedSpeed">
            <summary>
            Like <see cref="F:Animancer.FadeMode.FixedSpeed"/>, except that the fade duration is multiplied by the animation length.
            </summary>
        </member>
        <member name="F:Animancer.FadeMode.NormalizedDuration">
            <summary>
            Like <see cref="F:Animancer.FadeMode.FixedDuration"/>, except that the fade duration is multiplied by the animation length.
            </summary>
        </member>
        <member name="F:Animancer.FadeMode.NormalizedFromStart">
            <summary>
            Like <see cref="F:Animancer.FadeMode.FromStart"/>, except that the fade duration is multiplied by the animation length.
            </summary>
        </member>
        <member name="T:Animancer.PlayableAssetState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which plays a <see cref="T:UnityEngine.Playables.PlayableAsset"/>.
            </summary>
        </member>
        <member name="F:Animancer.PlayableAssetState._Asset">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableAsset"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Asset">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableAsset"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.MainObject">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableAsset"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Length">
            <summary>The <see cref="P:UnityEngine.Playables.PlayableAsset.duration"/>.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.ApplyAnimatorIK">
            <summary>IK cannot be dynamically enabled on a <see cref="T:Animancer.PlayableAssetState"/>.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.#ctor(UnityEngine.Playables.PlayableAsset)">
            <summary>Constructs a new <see cref="T:Animancer.PlayableAssetState"/> to play the `asset`.</summary>
            <exception cref="T:System.ArgumentNullException">The `asset` is null.</exception>
        </member>
        <member name="M:Animancer.PlayableAssetState.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Playables.Playable"/> managed by this node.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Bindings">
            <summary>The objects controlled by each Timeline Track.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.SetBindings(UnityEngine.Object[])">
            <summary>Sets the <see cref="P:Animancer.PlayableAssetState.Bindings"/>.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Destroy">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/> and cleans up this state.</summary>
            <remarks>
            This method is NOT called automatically, so when implementing a custom state type you must use
            <see cref="P:Animancer.AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up.
            </remarks>
        </member>
        <member name="T:Animancer.PlayableAssetState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.ITransition"/> which can create a <see cref="T:Animancer.PlayableAssetState"/> when
            passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.Asset">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The asset to play.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.Key">
            <summary>
            The <see cref="P:Animancer.PlayableAssetState.Transition.Asset"/> will be used as the <see cref="P:Animancer.AnimancerState.Key"/> for the created state to
            be registered with.
            </summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.Speed">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines how fast the animation plays (1x = normal speed, 2x = double speed).
            </summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.NormalizedStartTime">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines what <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to start the animation at.
            <para></para>
            The default value is <see cref="F:System.Single.NaN"/> which indicates that this value is not used so the
            animation will continue from its current time.
            </summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.FadeMode">
            <summary>
            If this transition will set the <see cref="P:Animancer.AnimancerState.NormalizedTime"/>, then it needs to use
            <see cref="F:Animancer.FadeMode.FromStart"/>.
            </summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.Bindings">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The objects controlled by each of the tracks in the Timeline Asset.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.MaximumDuration">
            <summary>[<see cref="T:Animancer.ITransitionDetailed"/>]
            The maximum amount of time the animation is expected to take (in seconds).
            </summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Transition.IsValid">
            <summary>Indicates whether this transition can create a valid <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Transition.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.PlayableAssetState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method
            as well. Or you can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Transition.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> to apply the <see cref="P:Animancer.PlayableAssetState.Transition.Speed"/>
            and <see cref="P:Animancer.PlayableAssetState.Transition.NormalizedStartTime"/>.
            </summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Transition.Animancer#IAnimationClipCollection#GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Gathers all the animations associated with this object.</summary>
        </member>
        <member name="T:Animancer.PlayableAssetState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.PlayableAssetState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Transition.Drawer.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.PlayableAssetState.Transition.Drawer"/>.</summary>
        </member>
        <member name="T:Animancer.SoloAnimationInternal">
            <summary>Plays a single <see cref="T:UnityEngine.AnimationClip"/> on startup.</summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Animator">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="T:UnityEngine.Animator"/> component which this script controls.
            <para></para>
            If you need to set this value at runtime you are likely better off using a proper
            <see cref="!:AnimancerComponent"/>.
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Clip">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="T:UnityEngine.AnimationClip"/> which will be played by <see cref="M:Animancer.SoloAnimationInternal.OnEnable"/>.
            <para></para>
            If you need to set this value at runtime you are likely better off using a proper
            <see cref="!:AnimancerComponent"/>.
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.StopOnDisable">
            <summary>
            If true, disabling this object will stop and rewind the animation. Otherwise it will simply be paused
            and will resume from its current state when it is re-enabled.
            <para></para>
            The default value is true.
            <para></para>
            This property wraps <see cref="P:UnityEngine.Animator.keepAnimatorControllerStateOnDisable"/> and inverts its value.
            The value is serialized by the <see cref="T:UnityEngine.Animator"/>.
            </summary>
        </member>
        <member name="F:Animancer.SoloAnimationInternal._Graph">
            <summary>
            The <see cref="T:UnityEngine.Playables.PlayableGraph"/> being used to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.
            </summary>
        </member>
        <member name="F:Animancer.SoloAnimationInternal._Playable">
            <summary>
            The <see cref="T:UnityEngine.Animations.AnimationClipPlayable"/> being used to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.IsPlaying">
            <summary>
            Indicates whether the animation is playing (true) or paused (false).
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Speed">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The speed at which the animation is playing (default 1).
            </summary>
            <exception cref="T:System.ArgumentException">This component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.FootIK">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines whether Foot IK will be applied to the model (if it is Humanoid).
            <para></para>
            The developers of Unity have states that they believe it looks better with this enabled, but more often
            than not it just makes the legs end up in a slightly different pose to what the animator intended.
            </summary>
            <exception cref="T:System.ArgumentException">This component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Time">
            <summary>
            The number of seconds that have passed since the start of the animation.
            </summary>
            <exception cref="T:System.ArgumentException">This component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.NormalizedTime">
            <summary>
            The <see cref="P:Animancer.SoloAnimationInternal.Time"/> of this state as a portion of the <see cref="P:UnityEngine.AnimationClip.length"/>, meaning the
            value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes.
            <para></para>
            This value will continue increasing after the animation passes the end of its length and it will either
            freeze in place or start again from the beginning according to whether it is looping or not.
            <para></para>
            The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the
            current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has
            been looped.
            </summary>
            <exception cref="T:System.ArgumentException">This component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.IsInitialised">
            <summary>Indicates whether the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is valid.</summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Reset">
            <summary>[Editor-Only]
            Called by the Unity Editor when this component is first added (in Edit Mode) and whenever the Reset command
            is executed from its context menu.
            <para></para>
            Tries to find an <see cref="T:UnityEngine.Animator"/> component on this <see cref="T:UnityEngine.GameObject"/> or its
            children or parents (in that order).
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnValidate">
            <summary>[Editor-Only]
            Called by the Unity Editor in Edit Mode whenever an instance of this script is loaded or a value is changed
            in the Inspector.
            <para></para>
            Tries to find an <see cref="T:UnityEngine.Animator"/> component on this <see cref="T:UnityEngine.GameObject"/> or its
            parents or children (in that order).
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Awake">
            <summary>
            Called by Unity when this component is first created.
            <para></para>
            Initialises everything needed to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnEnable">
            <summary>
            Called by Unity when this component becomes enabled and active.
            <para></para>
            Plays the <see cref="P:Animancer.SoloAnimationInternal.Clip"/> on the target <see cref="P:Animancer.SoloAnimationInternal.Animator"/>.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Update">
            <summary>
            Called by Unity every frame while this component is enabled and active.
            <para></para>
            Checks if the animation is done so it can pause the <see cref="T:UnityEngine.Playables.PlayableGraph"/> to improve performance.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnDisable">
            <summary>
            Called by Unity when this component becomes disabled or inactive.
            <para></para>
            Ensures that the <see cref="F:Animancer.SoloAnimationInternal._Graph"/> is properly cleaned up.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnDestroy">
            <summary>
            Called by Unity when this component is destroyed.
            <para></para>
            Ensures that the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is properly cleaned up.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Finalize">
            <summary>[Editor-Only]
            Ensures that the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is destroyed.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:UnityEngine.IAnimationClipSource"/>]
            Adds the <see cref="P:Animancer.SoloAnimationInternal.Clip"/> to the list.
            </summary>
        </member>
        <member name="T:Animancer.Strings">
            <summary>Various string constants used throughout Animancer.</summary>
        </member>
        <member name="F:Animancer.Strings.MenuPrefix">
            <summary>The standard prefix for <see cref="P:UnityEngine.CreateAssetMenuAttribute.menuName"/>.</summary>
        </member>
        <member name="F:Animancer.Strings.ExamplesMenuPrefix">
            <summary>The standard prefix for <see cref="P:UnityEngine.CreateAssetMenuAttribute.menuName"/>.</summary>
        </member>
        <member name="F:Animancer.Strings.AssetMenuOrder">
            <summary>
            The base value for <see cref="P:UnityEngine.CreateAssetMenuAttribute.order"/> to group
            "Assets/Create/Animancer/..." menu items just under "Avatar Mask".
            </summary>
        </member>
        <member name="F:Animancer.Strings.DocumentationURL">
            <summary>The URL of the website where the Animancer documentation is hosted.</summary>
        </member>
        <member name="F:Animancer.Strings.APIDocumentationURL">
            <summary>The URL of the website where the Animancer API documentation is hosted.</summary>
        </member>
        <member name="F:Animancer.Strings.ExampleAPIDocumentationURL">
            <summary>The URL of the website where the Animancer API documentation is hosted.</summary>
        </member>
        <member name="F:Animancer.Strings.DeveloperEmail">
            <summary>The email address which handles support for Animancer.</summary>
        </member>
        <member name="F:Animancer.Strings.UnityEditor">
            <summary>The conditional compilation symbol for Editor-Only code.</summary>
        </member>
        <member name="F:Animancer.Strings.Assertions">
            <summary>The conditional compilation symbol for assertions.</summary>
        </member>
        <member name="F:Animancer.Strings.Indent">
            <summary>4 spaces for indentation.</summary>
        </member>
        <member name="F:Animancer.Strings.ProOnlyTag">
            <summary>[Internal]
            A prefix for tooltips on Pro-Only features.
            <para></para>
            "[Pro-Only] " in Animancer Lite or "" in Animancer Pro.
            </summary>
        </member>
        <member name="F:Animancer.Strings.NoRename">
            <summary>[Internal] [Lite-Only]
            Disables member renaming in a [<see cref="T:System.Reflection.ObfuscationAttribute"/>].
            </summary>
        </member>
        <member name="T:Animancer.Strings.DocsURLs">
            <summary>[Editor-Only] URLs of various documentation pages.</summary>
        </member>
        <member name="T:Animancer.WarningType">
            <summary>
            Bitwise flags used by <see cref="M:Animancer.Validate.IsEnabled(Animancer.WarningType)"/> and <see cref="M:Animancer.Validate.Disable(Animancer.WarningType)"/> to determine which
            warnings Animancer should give. All warnings are enabled by default, but are entirely compiled out of runtime
            builds (except development builds).
            </summary>
        </member>
        <member name="T:Animancer.Validate">
            <summary>
            Enforces various rules throughout the system, most of which are compiled out if UNITY_ASSERTIONS is not defined
            (by default, it is only defined in the Unity Editor and in Development Builds).
            </summary>
        </member>
        <member name="M:Animancer.Validate.Disable(Animancer.WarningType)">
            <summary>[Assert-Conditional] Disables the specified warning type. Supports bitwise combinations.</summary>
            <example>
            You can put the following method in any class to have it disable all warnings on startup:
            <code>
            #if UNITY_ASSERTIONS
                [UnityEngine.RuntimeInitializeOnLoadMethod(UnityEngine.RuntimeInitializeLoadType.BeforeSceneLoad)]
                private static void DisableAnimancerWarnings()
                {
                    Animancer.WarningType.All.Disable();
                }
            #endif
            </code></example>
        </member>
        <member name="M:Animancer.Validate.Enable(Animancer.WarningType)">
            <summary>[Assert-Conditional] Re-enables the specified warning type. Supports bitwise combinations.</summary>
        </member>
        <member name="M:Animancer.Validate.SetEnabled(Animancer.WarningType,System.Boolean)">
            <summary>[Assert-Conditional] Enables or disables the specified warning type. Supports bitwise combinations.</summary>
        </member>
        <member name="M:Animancer.Validate.Log(Animancer.WarningType,System.String,System.Object)">
            <summary>[Assert-Conditional] Logs the `message` as a warning if the `type` is enabled.</summary>
        </member>
        <member name="M:Animancer.Validate.IsEnabled(Animancer.WarningType)">
            <summary>[Assert-Only] Returns true if none of the specified warning types have been disabled.</summary>
        </member>
        <member name="M:Animancer.Validate.IsDisabled(Animancer.WarningType)">
            <summary>[Assert-Only] Returns true if all of the specified warning types are disabled.</summary>
        </member>
        <member name="M:Animancer.Validate.DisableTemporarily(Animancer.WarningType)">
            <summary>[Assert-Only] Disables the specified warnings and returns those that were previously enabled.</summary>
            <example><code>
            var warnings = WarningType.All.DisableTemporarily();
            // Do stuff.
            warnings.Enable();
            </code></example>
        </member>
        <member name="M:Animancer.Validate.AssertNotLegacy(UnityEngine.AnimationClip)">
            <summary>[Assert-Conditional] Throws if the `clip` is marked as <see cref="P:UnityEngine.AnimationClip.legacy"/>.</summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.Validate.AssertRoot(Animancer.AnimancerNode,Animancer.AnimancerPlayable)">
            <summary>[Assert-Conditional] Throws if the <see cref="P:Animancer.AnimancerNode.Root"/> is not the `root`.</summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.Validate.AssertPlayable(Animancer.AnimancerNode)">
            <summary>[Assert-Conditional] Throws if the state's <see cref="T:UnityEngine.Playables.Playable"/> is invalid.</summary>
            <exception cref="T:System.InvalidOperationException"/>
        </member>
        <member name="M:Animancer.Validate.AssertCanRemoveChild(Animancer.AnimancerState,System.Collections.Generic.IList{Animancer.AnimancerState})">
            <summary>[Assert-Conditional]
            Throws if the `state` was not actually assigned to its specified <see cref="P:Animancer.AnimancerNode.Index"/> in
            the `states`.
            </summary>
            <exception cref="T:System.InvalidOperationException"/>
            <exception cref="T:System.IndexOutOfRangeException">
            The <see cref="P:Animancer.AnimancerNode.Index"/> is larger than the number of `states`.
            </exception>
        </member>
        <member name="M:Animancer.Validate.LiteFadeDuration(System.Single@,System.String,System.Object)">
            <summary>[Internal] [Lite-Only]
            Ensures that only the <see cref="F:Animancer.AnimancerPlayable.DefaultFadeDuration"/> can be used (warn in Editor,
            enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteWeight(System.Single@,System.String,System.Object)">
            <summary>[Internal] [Lite-Only]
            Ensures that only 0 or 1 weight can be used (warn in Editor, enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteSpeed(System.Single@,System.Object)">
            <summary>[Internal] [Lite-Only]
            Ensures that only 1 speed can be used (warn in Editor, enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteTime(System.Single@,System.Object)">
            <summary>[Internal] [Lite-Only]
            Ensures that only 0 time can be used (warn in Editor, enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteNodeType(Animancer.AnimancerNode)">
            <summary>[Internal] [Lite-Only]
            Ensures that only inbuilt <see cref="T:Animancer.AnimancerNode"/> types can be used (warn in Editor, enforce at
            Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteUpdatableType(Animancer.IUpdatable,System.Object)">
            <summary>[Internal] [Lite-Only]
            Ensures that only inbuilt <see cref="T:Animancer.AnimancerNode"/> types can be used (warn in Editor, enforce at
            Runtime).
            </summary>
        </member>
        <member name="F:Animancer.Validate.ProOnlyMessage">
            <summary>[Lite-Only]
            A message which explains that some features are only available in the Unity Editor for trial purposes in
            Animancer Lite, but not at runtime.
            </summary>
        </member>
        <member name="M:Animancer.Validate.LogProOnlyFeature(System.String,System.Object)">
            <summary>[Internal] [Lite-Only]
            Logs a message the first time each Pro-Only `feature` is used.
            </summary>
        </member>
        <member name="T:Animancer.IAnimancerComponent">
            <summary>
            Interface for components that manage an <see cref="T:Animancer.AnimancerPlayable"/>.
            </summary>
            <remarks>
            Despite the name, this interface is not necessarily limited to only <see cref="T:UnityEngine.Component"/>s.
            <para></para>
            This interface allows Animancer Lite to reference an <see cref="!:AnimancerComponent"/> inside the pre-compiled
            DLL while allowing that component to remain outside as a regular script. Otherwise everything would need to be
            in the DLL which would cause Unity to lose all the script references when upgrading from Animancer Lite to Pro.
            </remarks>
        </member>
        <member name="P:Animancer.IAnimancerComponent.enabled">
            <summary>Indicates whether this component will be updated.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.gameObject">
            <summary>The <see cref="T:UnityEngine.GameObject"/> this component is attached to.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.Animator">
            <summary>The <see cref="T:UnityEngine.Animator"/> component which this script controls.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.Playable">
            <summary>The internal system which manages the playing animations.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.IsPlayableInitialised">
            <summary>Indicates whether the <see cref="P:Animancer.IAnimancerComponent.Playable"/> has been initialised (is not null).</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.ResetOnDisable">
            <summary>Determines whether the object will be reset to its original values when disabled.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.UpdateMode">
            <summary>
            Determines when animations are updated and which time source is used. This property is mainly a wrapper
            around the <see cref="P:UnityEngine.Animator.updateMode"/>.
            </summary>
        </member>
        <member name="M:Animancer.IAnimancerComponent.GetKey(UnityEngine.AnimationClip)">
            <summary>Returns the dictionary key to use for the `clip`.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.AnimatorFieldName">
            <summary>[Editor-Only] The name of the serialized backing field for the <see cref="P:Animancer.IAnimancerComponent.Animator"/> property.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.ActionOnDisableFieldName">
            <summary>[Editor-Only] The name of the serialized backing field for the <see cref="!:ActionOnDisable"/> property.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.InitialUpdateMode">
            <summary>[Editor-Only] The <see cref="P:Animancer.IAnimancerComponent.UpdateMode"/> what was first used when this script initialised.</summary>
        </member>
        <member name="T:Animancer.IAnimationClipCollection">
            <summary>
            A variant of <see cref="T:UnityEngine.IAnimationClipSource"/> which uses a <see cref="T:System.Collections.Generic.ICollection`1"/> instead of a
            <see cref="T:System.Collections.Generic.List`1"/> so that it can take a <see cref="T:System.Collections.Generic.HashSet`1"/> to efficiently avoid adding duplicates.
            <see cref="T:Animancer.AnimancerUtilities"/> contains various extension methods for this purpose.
            <para></para>
            <see cref="T:UnityEngine.IAnimationClipSource"/> still needs to be the main point of entry for the Animation Window, so this
            interface is only used internally.
            </summary>
        </member>
        <member name="M:Animancer.IAnimationClipCollection.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Gathers all the animations associated with this object.</summary>
        </member>
        <member name="T:Animancer.ICharacterRoot">
            <summary>
            Interface for components to indicate which <see cref="T:UnityEngine.GameObject"/> is the root of a character when
            <see cref="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.GameObject)"/> is called.
            </summary>
        </member>
        <member name="P:Animancer.ICharacterRoot.transform">
             <summary>
             The <see cref="T:UnityEngine.Transform"/> to search for <see cref="T:UnityEngine.AnimationClip"/>s beneath.
             </summary>
            
             <example>
             Implementing this interface in a <see cref="T:UnityEngine.MonoBehaviour"/> will automatically inherit this property so
             you do not need to do anything else:
             <code>public class MyComponent : MonoBehaviour, IAnimancerRoot
             {
             }</code>
             But if you want to have your script point to a different object as the root, you can explicitly implement
             this property:
             <code>public class MyComponent : MonoBehaviour, IAnimancerRoot
             {
                 Transform IAnimancerRoot.transform => ???; } }
             }</code>
             </example>
        </member>
        <member name="T:Animancer.IHasIK">
            <summary>
            A node which has an Inverse Kinematics system that can be enabled and disabled.
            </summary>
        </member>
        <member name="P:Animancer.IHasIK.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="P:Animancer.IHasIK.ApplyAnimatorIK">
            <summary>
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object while this
            node is active. The initial value is determined by <see cref="P:Animancer.AnimancerPlayable.DefaultApplyAnimatorIK"/>
            when a new state is created and setting this value will also set the default.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers, except that due to limitations in
            the Playables API the <c>layerIndex</c> will always be zero.
            </summary>
        </member>
        <member name="P:Animancer.IHasIK.ApplyFootIK">
            <summary>
            Determines whether this node or any of its children should apply IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerPlayable.DefaultApplyFootIK"/> when a new state is
            created.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states.
            </summary>
        </member>
        <member name="T:Animancer.IHasKey">
            <summary>
            Exposes a <see cref="P:Animancer.IHasKey.Key"/> object that can be used for dictionaries and hash sets.
            </summary>
        </member>
        <member name="P:Animancer.IHasKey.Key">
            <summary>An identifier object that can be used for dictionaries and hash sets.</summary>
        </member>
        <member name="T:Animancer.IPlayableWrapper">
            <summary>
            Interface for objects that manage a <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.Parent">
            <summary>The object which receives the output of the <see cref="P:Animancer.IPlayableWrapper.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.Playable">
            <summary>The <see cref="T:UnityEngine.Playables.Playable"/> managed by this object.</summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.KeepChildrenConnected">
            <summary>
            Indicates whether child playables should stay connected to the graph at all times.
            <para></para>
            If false, playables will be disconnected from the graph while they are at 0 weight to stop it from
            evaluating them every frame.
            </summary>
            <seealso cref="P:Animancer.AnimancerPlayable.KeepChildrenConnected"/>
        </member>
        <member name="P:Animancer.IPlayableWrapper.Speed">
             <summary>
             How fast the <see cref="T:UnityEngine.Time"/> is advancing every frame.
             <para></para>
             1 is the normal speed.
             <para></para>
             A negative value will play the animation backwards.
             <para></para>
             Animancer Lite does not allow this value to be changed in a runtime build.
             </summary>
            
             <example>
             <code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.Speed = 1;// Normal speed.
                 state.Speed = 2;// Double speed.
                 state.Speed = 0.5f;// Half speed.
                 state.Speed = -1;// Normal speed playing backwards.
             }
             </code>
             </example>
        </member>
        <member name="T:Animancer.ITransition">
            <summary>
            An object that can create an <see cref="T:Animancer.AnimancerState"/> and manage the details of how it should be played.
            <para></para>
            Transitions are generally used as arguments for <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ITransition.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.AnimancerState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method as well. Or you
            can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            </summary>
            <remarks>
            The first time a transition is used on an object, this method is called to create the state and register it
            in the internal dictionary using the <see cref="P:Animancer.IHasKey.Key"/> so that it can be reused later on.
            </remarks>
        </member>
        <member name="P:Animancer.ITransition.FadeMode">
            <summary>
            When a transition is passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>, this property
            determines which <see cref="T:Animancer.FadeMode"/> will be used.
            </summary>
        </member>
        <member name="P:Animancer.ITransition.FadeDuration">
            <summary>The amount of time the transition should take (in seconds).</summary>
        </member>
        <member name="M:Animancer.ITransition.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> to apply any modifications to the `state`.
            </summary>
            <remarks>
            Unlike <see cref="M:Animancer.ITransition.CreateState"/>, this method is called every time the transition is used so it can do
            things like set the <see cref="P:Animancer.AnimancerState.Events"/> or <see cref="P:Animancer.AnimancerState.Time"/>.
            </remarks>
        </member>
        <member name="T:Animancer.ITransitionDetailed">
            <summary>
            An <see cref="T:Animancer.ITransition"/> with some additional details for the Unity Editor GUI.
            </summary>
        </member>
        <member name="P:Animancer.ITransitionDetailed.IsLooping">
            <summary>Indicates what the value of <see cref="P:Animancer.AnimancerState.IsLooping"/> will be for the created state.</summary>
        </member>
        <member name="P:Animancer.ITransitionDetailed.NormalizedStartTime">
            <summary>Determines what <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to start the animation at.</summary>
        </member>
        <member name="P:Animancer.ITransitionDetailed.Speed">
            <summary>Determines how fast the animation plays (1x = normal speed).</summary>
        </member>
        <member name="P:Animancer.ITransitionDetailed.MaximumDuration">
            <summary>The maximum amount of time the animation is expected to take (in seconds).</summary>
        </member>
        <member name="P:Animancer.ITransitionDetailed.IsValid">
            <summary>Indicates whether this transition can create a valid <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.ITransitionDetailed.AddItemsToContextMenu(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,Animancer.Editor.Serialization.PropertyAccessor)">
            <summary>[Editor-Only] Adds context menu functions for this transition.</summary>
        </member>
        <member name="T:Animancer.IUpdatable">
             <summary>
             An object that can be updated during <see cref="M:UnityEngine.Playables.PlayableBehaviour.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/>.
             <para></para>
             Register to receive updates using <see cref="M:Animancer.AnimancerPlayable.RequireUpdate(Animancer.IUpdatable)"/> and stop
             receiving updates using <see cref="M:Animancer.AnimancerPlayable.CancelUpdate(Animancer.IUpdatable)"/>.
             </summary>
            
             <example><code>
             public sealed class UpdatableBehaviour : MonoBehaviour, IUpdatable
             {
                 [SerializeField] private AnimancerComponent _Animancer;
            
                 private void OnEnable()
                 {
                     _Animancer.Playable.RequireUpdate(this);
                 }
            
                 private void OnEnable()
                 {
                     _Animancer.Playable.CancelUpdate(this);
                 }
            
                 public void EarlyUpdate()
                 {
                     // Called at the start of every Animator update before the playables get updated.
                 }
            
                 public void LateUpdate()
                 {
                     // Called at the end of every Animator update after the playables get updated.
                 }
            
                 public void OnDestroy()
                 {
                     // Called by AnimancerPlayable.Destroy if this object is currently being updated.
                 }
             }
             </code></example>
        </member>
        <member name="M:Animancer.IUpdatable.EarlyUpdate">
            <summary>Called at the start of every <see cref="T:UnityEngine.Animator"/> update before the playables get updated.</summary>
            <remarks>The <see cref="P:UnityEngine.Animator.updateMode"/> determines when it updates.</remarks>
        </member>
        <member name="M:Animancer.IUpdatable.LateUpdate">
            <summary>Called at the end of every <see cref="T:UnityEngine.Animator"/> update after the playables get updated.</summary>
            <remarks>
            The <see cref="P:UnityEngine.Animator.updateMode"/> determines when it updates.
            This method has nothing to do with <see cref="T:UnityEngine.MonoBehaviour"/>.LateUpdate().
            </remarks>
        </member>
        <member name="M:Animancer.IUpdatable.OnDestroy">
            <summary>Called by <see cref="M:Animancer.AnimancerPlayable.Destroy"/> if this object is currently being updated.</summary>
        </member>
        <member name="T:Animancer.CartesianMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together based on a two dimensional
            parameter and thresholds using Gradient Band Interpolation.
            <para></para>
            This mixer type is similar to the 2D Freeform Cartesian Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="F:Animancer.CartesianMixerState._BlendFactors">
            <summary>Precalculated values to speed up the recalculation of weights.</summary>
        </member>
        <member name="F:Animancer.CartesianMixerState._BlendFactorsDirty">
            <summary>Indicates whether the <see cref="F:Animancer.CartesianMixerState._BlendFactors"/> need to be recalculated.</summary>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterX">
            <summary>Gets or sets Parameter.x.</summary>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterY">
            <summary>Gets or sets Parameter.y.</summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. Indicates that the internal blend factors need to be
            recalculated and calls <see cref="M:Animancer.CartesianMixerState.ForceRecalculateWeights"/>.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.ForceRecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="F:Animancer.ManualMixerState._States"/> based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the <see cref="F:Animancer.MixerState`1._Thresholds"/>.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.AppendParameter(System.Text.StringBuilder,UnityEngine.Vector2)">
            <summary>Appends the `parameter` in a viewer-friendly format.</summary>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.CartesianMixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.DirectionalMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together based on a two dimensional
            parameter and thresholds using Polar Gradient Band Interpolation.
            <para></para>
            This mixer type is similar to the 2D Freeform Directional Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState._ThresholdMagnitudes">
            <summary>Precalculated magnitudes of all thresholds to speed up the recalculation of weights.</summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState._BlendFactors">
            <summary>Precalculated values to speed up the recalculation of weights.</summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState._BlendFactorsDirty">
            <summary>Indicates whether the <see cref="F:Animancer.DirectionalMixerState._BlendFactors"/> need to be recalculated.</summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState.AngleFactor">
            <summary>The multiplier that controls how much an angle (in radians) is worth compared to normalized distance.</summary>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterX">
            <summary>Gets or sets Parameter.x.</summary>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterY">
            <summary>Gets or sets Parameter.y.</summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. Indicates that the internal blend factors need to be
            recalculated and calls <see cref="M:Animancer.DirectionalMixerState.ForceRecalculateWeights"/>.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.ForceRecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="F:Animancer.ManualMixerState._States"/> based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the thresholds.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.AppendParameter(System.Text.StringBuilder,UnityEngine.Vector2)">
            <summary>Appends the `parameter` in a viewer-friendly format.</summary>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.DirectionalMixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.LinearMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together using linear interpolation
            between the specified thresholds.
            <para></para>
            This mixer type is similar to the 1D Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="P:Animancer.LinearMixerState.ExtrapolateSpeed">
            <summary>
            Should setting the <see cref="P:Animancer.MixerState`1.Parameter"/> above the highest threshold increase the
            <see cref="P:Animancer.AnimancerNode.Speed"/> of this mixer proportionally?
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Initialise(UnityEngine.AnimationClip[],System.Single,System.Single)">
            <summary>
            Initialises the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> and <see cref="F:Animancer.ManualMixerState._States"/> with one
            state per clip and assigns thresholds evenly spaced between the specified min and max (inclusive).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Initialise(UnityEngine.AnimationClip,UnityEngine.AnimationClip,System.Single,System.Single)">
            <summary>
            Initialises the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> with two ports and connects two states to them for
            the specified clips at the specified thresholds (default 0 and 1).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Initialise(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip,System.Single,System.Single,System.Single)">
            <summary>
            Initialises the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> with three ports and connects three states to them for
            the specified clips at the specified thresholds (default -1, 0, and 1).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. Indicates that <see cref="M:Animancer.LinearMixerState.AssertThresholdsSorted"/> needs to
            be called by the next <see cref="M:Animancer.LinearMixerState.ForceRecalculateWeights"/> if UNITY_ASSERTIONS is defined, then calls
            <see cref="M:Animancer.MixerState`1.OnThresholdsChanged"/>.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.AssertThresholdsSorted">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if the thresholds are not sorted from lowest to highest without
            any duplicates.
            </summary>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.InvalidOperationException">The thresholds have not been initialised.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.ForceRecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="F:Animancer.ManualMixerState._States"/> based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the thresholds.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.AssignLinearThresholds(System.Single,System.Single)">
            <summary>
            Assigns the thresholds to be evenly spaced between the specified min and max (inclusive).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)"/> to append the details of this node.</summary>
        </member>
        <member name="P:Animancer.LinearMixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.CreateDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.LinearMixerState.Drawer"/> for this state.</summary>
        </member>
        <member name="T:Animancer.LinearMixerState.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.ControllerState"/>.</summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Drawer.#ctor(Animancer.LinearMixerState)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState.Drawer"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Drawer.AddContextMenuFunctions(UnityEditor.GenericMenu)">
            <summary>Adds the details of this state to the `menu`.</summary>
        </member>
        <member name="T:Animancer.LinearMixerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.ITransition"/> which can create a <see cref="T:Animancer.LinearMixerState"/> when
            passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="P:Animancer.LinearMixerState.Transition.ExtrapolateSpeed">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Should setting the <see cref="P:Animancer.MixerState`1.Parameter"/> above the highest threshold increase the
            <see cref="P:Animancer.AnimancerNode.Speed"/> of the mixer proportionally?
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Transition.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.LinearMixerState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method
            as well. Or you can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Transition.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> to apply the
            <see cref="P:Animancer.AnimancerNode.Speed"/> and <see cref="P:Animancer.LinearMixerState.Transition.ExtrapolateSpeed"/>.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Transition.SortByThresholds">
            <summary>
            Sorts all states so that their thresholds go from lowest to highest.
            <para></para>
            This method uses Bubble Sort which is inefficient for large numbers of states.
            </summary>
        </member>
        <member name="T:Animancer.LinearMixerState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.LinearMixerState.Transition"/>.</summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Transition.Drawer.DoThresholdGUI(UnityEngine.Rect,System.Int32)">
            <summary>Draws the GUI of the threshold at the specified `index`.</summary>
        </member>
        <member name="P:Animancer.LinearMixerState.Transition.Drawer.HasThresholdContextMenu">
            <summary><see cref="M:Animancer.LinearMixerState.Transition.Drawer.AddThresholdFunctionsToMenu(UnityEditor.GenericMenu)"/> will add some functions to the menu.</summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Transition.Drawer.AddThresholdFunctionsToMenu(UnityEditor.GenericMenu)">
            <summary>Adds functions to the `menu` relating to the thresholds.</summary>
        </member>
        <member name="T:Animancer.ManualMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends multiple child states. Unlike other mixers, this class does not
            perform any automatic weight calculations, it simple allows you to control the weight of all states manually.
            <para></para>
            This mixer type is similar to the Direct Blend Type in Mecanim Blend Trees.
            The official <a href="https://learn.unity.com/tutorial/5c5152bcedbc2a001fd5c696">Direct Blend Trees</a>
            tutorial explains their general concepts and purpose which apply to <see cref="T:Animancer.ManualMixerState"/>s as well.
            </summary>
        </member>
        <member name="F:Animancer.ManualMixerState.NoStates">
            <summary>An empty array of states.</summary>
        </member>
        <member name="F:Animancer.ManualMixerState._States">
            <summary>The states managed by this mixer.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.ChildStates">
            <summary>Returns the <see cref="F:Animancer.ManualMixerState._States"/>.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.ChildCount">
            <summary>The number of states using this mixer as their <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.GetChild(System.Int32)">
            <summary>Returns the state connected to the specified `index` as a child of this mixer.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Initialise(System.Int32)">
            <summary>
            Initialises this mixer with the specified number of children which can be set individually by
            <see cref="M:Animancer.MixerState.CreateChild(System.Int32,UnityEngine.AnimationClip)"/> and <see cref="M:Animancer.MixerState.SetChild(System.Int32,Animancer.AnimancerState)"/>.
            </summary>
            <remarks><see cref="M:Animancer.AnimancerState.Destroy"/> will be called on any existing children.</remarks>
        </member>
        <member name="M:Animancer.ManualMixerState.Initialise(UnityEngine.AnimationClip[])">
            <summary>
            Initialises this mixer with one state per clip.
            </summary>
        </member>
        <member name="T:Animancer.ManualMixerState.Transition`1">
            <summary>
            Base class for serializable <see cref="T:Animancer.ITransition"/>s which can create a particular type of
            <see cref="T:Animancer.ManualMixerState"/> when passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            <para></para>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition`1.Speed">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            Determines how fast the mixer plays (1x = normal speed, 2x = double speed).
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition`1.Clips">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.ClipState.Clip"/> to use for each state in the mixer.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition`1.Speeds">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.AnimancerNode.Speed"/> to use for each state in the mixer.
            <para></para>
            If the size of this array doesn't match the <see cref="P:Animancer.ManualMixerState.Transition`1.Clips"/>, it will be ignored.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition`1.SynchroniseChildren">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="P:Animancer.MixerState.SynchroniseChildren"/> flags for each state in the mixer.
            <para></para>
            The array can be null or empty. Any elements not in the array will be treated as true.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition`1.IsLooping">
            <summary>[<see cref="T:Animancer.ITransitionDetailed"/>]
            Returns true is any of the <see cref="P:Animancer.ManualMixerState.Transition`1.Clips"/> are looping.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition`1.MaximumDuration">
            <summary>[<see cref="T:Animancer.ITransitionDetailed"/>]
            The maximum amount of time the animation is expected to take (in seconds).
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition`1.InitialiseState">
            <summary>
            Initialises the <see cref="P:Animancer.AnimancerState.Transition`1.State"/> immediately after it is created.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition`1.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> to apply the <see cref="P:Animancer.ManualMixerState.Transition`1.Speed"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition`1.Animancer#IAnimationClipCollection#GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Adds the <see cref="P:Animancer.ManualMixerState.Transition`1.Clips"/> to the collection.</summary>
        </member>
        <member name="T:Animancer.ManualMixerState.Transition">
            <summary>
            A serializable <see cref="T:Animancer.ITransition"/> which can create a <see cref="T:Animancer.ManualMixerState"/> when
            passed into <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            </remarks>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ManualMixerState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method
            as well. Or you can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.ManualMixerState.Transition.Drawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.ManualMixerState.Transition"/>.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition.Drawer.CurrentProperty">
            <summary>
            The property this drawer is currently drawing.
            <para></para>
            Normally each property has its own drawer, but arrays share a single drawer for all elements.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition.Drawer.CurrentClips">
            <summary>The <see cref="P:Animancer.ManualMixerState.Transition`1.Clips"/> field.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSpeeds">
            <summary>The <see cref="P:Animancer.ManualMixerState.Transition`1.Speeds"/> field.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSynchroniseChildren">
            <summary>The <see cref="P:Animancer.ManualMixerState.Transition`1.SynchroniseChildren"/> field.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.GatherDetails(UnityEditor.SerializedProperty)">
            <summary>
            Gather the details of the `property`.
            <para></para>
            This method gets called by every <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> and <see cref="M:Animancer.ManualMixerState.Transition.Drawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> call since
            Unity uses the same <see cref="T:UnityEditor.PropertyDrawer"/> instance for each element in a collection, so it
            needs to gather the details associated with the current property.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.GatherSubProperties(UnityEditor.SerializedProperty)">
            <summary>
            Called every time a `property` is drawn to find the relevant child properties and store them to be
            used in <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> and <see cref="M:Animancer.ManualMixerState.Transition.Drawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.GatherSubPropertiesStatic(UnityEditor.SerializedProperty)">
            <summary>
            Called every time a `property` is drawn to find the relevant child properties and store them to be
            used in <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> and <see cref="M:Animancer.ManualMixerState.Transition.Drawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.AddPropertyModifierFunction(UnityEditor.GenericMenu,System.String,Animancer.Editor.MenuFunctionState,System.Action{UnityEditor.SerializedProperty})">
            <summary>
            Adds a menu item that will call <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GatherSubPropertiesStatic(UnityEditor.SerializedProperty)"/> then run the specified
            `function`.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.AddPropertyModifierFunction(UnityEditor.GenericMenu,System.String,System.Action{UnityEditor.SerializedProperty})">
            <summary>
            Adds a menu item that will call <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GatherSubPropertiesStatic(UnityEditor.SerializedProperty)"/> then run the specified
            `function`.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Calculates the number of vertical pixels the `property` will occupy when it is drawn.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Draws the root `property` GUI and calls
            <see cref="M:Animancer.Editor.TransitionDrawer.DoPropertyGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> for each of its children.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.SplitListRect(UnityEngine.Rect,System.Boolean,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>Splits the specified `area` into separate sections.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoStateListHeaderGUI(UnityEngine.Rect)">
            <summary>Draws the headdings of the state list.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoAnimationHeaderGUI(UnityEngine.Rect)">
            <summary>Draws an "Animation" header.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoSpeedHeaderGUI(UnityEngine.Rect)">
            <summary>Draws a "Speed" header.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.NormalizeDurations(UnityEditor.SerializedProperty)">
            <summary>
            Recalculates the <see cref="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSpeeds"/> depending on the <see cref="P:UnityEngine.AnimationClip.length"/> of
            their animations so that they all take the same amount of time to play fully.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.InitialiseSpeeds(System.Int32)">
            <summary>
            Initialises every element in the <see cref="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSpeeds"/> array from the `start` to the end of
            the array to contain a value of 1.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoSyncHeaderGUI(UnityEngine.Rect)">
            <summary>Draws a "Sync" header.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoHeaderDropdownGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent,System.Action{UnityEditor.GenericMenu})">
            <summary>Draws the GUI for a header dropdown button.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.GetElementHeight(System.Int32)">
            <summary>Calculates the height of the state at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoElementGUI(UnityEngine.Rect,System.Int32,System.Boolean,System.Boolean)">
            <summary>Draws the GUI of the state at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoElementGUI(UnityEngine.Rect,System.Int32,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Draws the GUI of the state at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoElementGUI(UnityEngine.Rect,UnityEngine.Rect,UnityEngine.Rect,System.Int32,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Draws the GUI of the state at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.DoSyncToggleGUI(UnityEngine.Rect,System.Int32)">
            <summary>
            Draws a toggle to enable or disable <see cref="P:Animancer.MixerState.SynchroniseChildren"/> for the child at
            the specified `index`.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.OnAddElement(UnityEditorInternal.ReorderableList)">
            <summary>
            Called when adding a new state to the list to ensure that any other relevant arrays have new
            elements added as well.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.OnRemoveElement(UnityEditorInternal.ReorderableList)">
            <summary>
            Called when removing a state from the list to ensure that any other relevant arrays have elements
            removed as well.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.OnReorderList(UnityEditorInternal.ReorderableList,System.Int32,System.Int32)">
            <summary>
            Called when reordering states in the list to ensure that any other relevant arrays have their
            corresponding elements reordered as well.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.TryCollapseArrays">
            <summary>
            Calls <see cref="M:Animancer.ManualMixerState.Transition.Drawer.TryCollapseSpeeds"/> and <see cref="M:Animancer.ManualMixerState.Transition.Drawer.TryCollapseSync"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.TryCollapseSpeeds">
            <summary>
            If every element in the <see cref="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSpeeds"/> array is 1, this method sets the array size to 0.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Transition.Drawer.TryCollapseSync">
            <summary>
            Removes any true elements from the end of the <see cref="P:Animancer.ManualMixerState.Transition.Drawer.CurrentSynchroniseChildren"/> array.
            </summary>
        </member>
        <member name="T:Animancer.MixerState">
            <summary>[Pro-Only]
            Base class for <see cref="T:Animancer.AnimancerState"/>s which blend other states together.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.KeepChildrenConnected">
            <summary>Mixers should keep child playables connected to the graph at all times.</summary>
        </member>
        <member name="P:Animancer.MixerState.Clip">
            <summary>An <see cref="T:Animancer.MixerState"/> has no <see cref="T:UnityEngine.AnimationClip"/>.</summary>
        </member>
        <member name="P:Animancer.MixerState.ChildStates">
            <summary>
            Returns the collection of states connected to this mixer. Note that some elements may be null.
            <para></para>
            Getting an enumerator that automatically skips over null states is slower and creates garbage, so
            internally we use this property and perform null checks manually even though it increases the code
            complexity a bit.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.ChildCount">
            <summary>The number of states using this mixer as their <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState.GetChild(System.Int32)">
            <summary>
            Returns the state connected to the specified `index` as a child of this mixer.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.GetEnumerator">
            <summary>Returns an enumerator which will iterate through each state connected to this mixer.</summary>
        </member>
        <member name="P:Animancer.MixerState.IsPlaying">
            <summary>
            Determines whether the states in this mixer are playing.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.IsLooping">
            <summary>Returns true if any child state is looping.</summary>
        </member>
        <member name="P:Animancer.MixerState.RawTime">
            <summary>
            The weighted average <see cref="P:Animancer.AnimancerState.Time"/> of each child state according to their
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.Length">
            <summary>
            The weighted average <see cref="P:Animancer.AnimancerState.Length"/> of each child state according to their
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.SynchroniseChildren">
            <summary>
            Indicates which children should have their <see cref="P:Animancer.AnimancerNode.Speed"/> modified in order to keep
            their <see cref="P:Animancer.AnimancerState.NormalizedTime"/> at approximately the same value.
            <para></para>
            The array can be null or empty. Any elements not in the array will be treated as true.
            </summary>
            <remarks>
            The <see cref="P:Animancer.AnimancerNode.Speed"/> is modified to allow each state to trigger its events properly
            where setting the <see cref="P:Animancer.AnimancerState.NormalizedTime"/> directly would prevent any events.
            </remarks>
        </member>
        <member name="F:Animancer.MixerState.DontSynchroniseChildren">
            <summary>
            An empty array used by <see cref="P:Animancer.MixerState.SynchroniseChildren"/> as a special value to indicate that no children
            should be synchronised (instead of needing a properly sized array containing all false values).
            </summary>
        </member>
        <member name="M:Animancer.MixerState.#ctor">
            <summary>Constructs a new <see cref="T:Animancer.MixerState"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Playables.Playable"/> managed by this node.</summary>
        </member>
        <member name="M:Animancer.MixerState.CreateChild(System.Int32,UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` with this mixer as its parent.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.CreateChild(System.Int32,Animancer.ITransition)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/> and sets this mixer as the state's parent.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.SetChild(System.Int32,Animancer.AnimancerState)">
            <summary>Assigns the `state` as a child of this mixer.</summary>
        </member>
        <member name="M:Animancer.MixerState.OnAddChild(Animancer.AnimancerState)">
            <summary>Connects the `state` to this mixer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState.OnRemoveChild(Animancer.AnimancerState)">
            <summary>Disconnects the `state` from this mixer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState.Destroy">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/> and cleans up this state and its children.</summary>
            <remarks>
            This method is NOT called automatically, so when implementing a custom state type you must use
            <see cref="P:Animancer.AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up.
            </remarks>
        </member>
        <member name="M:Animancer.MixerState.DestroyChildren">
            <summary>
            Destroys all <see cref="P:Animancer.MixerState.ChildStates"/> connected to this mixer. This operation cannot be undone.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.CreatePlayable``1(Animancer.AnimancerPlayable,``0,System.Boolean)">
            <summary>
            Creates an <see cref="T:UnityEngine.Animations.AnimationScriptPlayable"/> to run the specified Animation Job instead of the usual
            <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/>.
            </summary>
            <example><code>
            var job = new MyJob();// A struct that implements IAnimationJob.
            var mixer = new WhateverMixerType();
            mixer.CreatePlayable(animancer, job);
            // Use mixer.Initialise and CreateState to make the children as normal.
            </code>
            See also: <seealso cref="M:Animancer.MixerState.CreatePlayable``1(UnityEngine.Playables.Playable@,``0,System.Boolean)"/>
            </example>
        </member>
        <member name="M:Animancer.MixerState.CreatePlayable``1(UnityEngine.Playables.Playable@,``0,System.Boolean)">
            <summary>
            Creates an <see cref="T:UnityEngine.Animations.AnimationScriptPlayable"/> to run the specified Animation Job instead of the usual
            <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/>.
            </summary>
            <example><code>
            public class MyMixer : LinearMixerState
            {
                protected override void CreatePlayable(out Playable playable)
                {
                    CreatePlayable(out playable, new MyJob());
                }
            
                private struct MyJob : IAnimationJob
                {
                    public void ProcessAnimation(AnimationStream stream)
                    {
                    }
            
                    public void ProcessRootMotion(AnimationStream stream)
                    {
                    }
                }
            }
            </code>
            See also: <seealso cref="M:Animancer.MixerState.CreatePlayable``1(Animancer.AnimancerPlayable,``0,System.Boolean)"/>
            </example>
        </member>
        <member name="M:Animancer.MixerState.GetJobData``1">
            <summary>
            Gets the Animation Job data from the <see cref="T:UnityEngine.Animations.AnimationScriptPlayable"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">
            This mixer was not initialised using <see cref="M:Animancer.MixerState.CreatePlayable``1(Animancer.AnimancerPlayable,``0,System.Boolean)"/>
            or <see cref="M:Animancer.MixerState.CreatePlayable``1(UnityEngine.Playables.Playable@,``0,System.Boolean)"/>.
            </exception>
        </member>
        <member name="M:Animancer.MixerState.SetJobData``1(``0)">
            <summary>
            Sets the Animation Job data in the <see cref="T:UnityEngine.Animations.AnimationScriptPlayable"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">
            This mixer was not initialised using <see cref="M:Animancer.MixerState.CreatePlayable``1(Animancer.AnimancerPlayable,``0,System.Boolean)"/>
            or <see cref="M:Animancer.MixerState.CreatePlayable``1(UnityEngine.Playables.Playable@,``0,System.Boolean)"/>.
            </exception>
        </member>
        <member name="M:Animancer.MixerState.Update(System.Boolean@)">
            <summary>
            Updates the time of this mixer and all of its child states.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.ApplySynchroniseChildren(System.Boolean@)">
            <summary>Applies the effects of <see cref="P:Animancer.MixerState.SynchroniseChildren"/>.</summary>
        </member>
        <member name="P:Animancer.MixerState.WeightsAreDirty">
            <summary>Indicates whether the weights of all child states should be recalculated.</summary>
        </member>
        <member name="M:Animancer.MixerState.RecalculateWeights">
            <summary>
            If <see cref="P:Animancer.MixerState.WeightsAreDirty"/> this method recalculates the weights of all child states and returns true.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.ForceRecalculateWeights">
            <summary>
            Recalculates the weights of all child states based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the thresholds.
            <para></para>
            Overrides of this method must set <see cref="P:Animancer.MixerState.WeightsAreDirty"/> = false.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.CalculateTotalChildWeight">
            <summary>
            Calculates the sum of the <see cref="P:Animancer.AnimancerNode.Weight"/> of all child states.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.SetChildrenTime(System.Single,System.Boolean)">
            <summary>
            Sets <see cref="P:Animancer.AnimancerState.Time"/> for all <see cref="P:Animancer.MixerState.ChildStates"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.DisableRemainingStates(System.Int32)">
            <summary>
            Sets the weight of all states after the `previousIndex` to 0.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.GetNextState(System.Int32@)">
            <summary>
            Returns the state at the specified `index` if it is not null, otherwise increments the index and checks
            again. Returns null if no state is found by the end of the <see cref="P:Animancer.MixerState.ChildStates"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.NormalizeWeights(System.Single)">
            <summary>
            Divides the weight of all states by the `totalWeight` so that they all add up to 1.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.GetDisplayKey(Animancer.AnimancerState)">
            <summary>Gets a user-friendly key to identify the `state` in the Inspector.</summary>
        </member>
        <member name="P:Animancer.MixerState.AverageVelocity">
            <summary>The average velocity of the root motion caused by this state.</summary>
        </member>
        <member name="M:Animancer.MixerState.NormalizeDurations">
            <summary>
            Recalculates the <see cref="P:Animancer.AnimancerState.Duration"/> of all child states so that they add up to 1.
            </summary>
            <exception cref="T:System.NullReferenceException">There are any states with no <see cref="P:Animancer.MixerState.Clip"/>.</exception>
        </member>
        <member name="M:Animancer.MixerState.ToString">
            <summary>
            Returns a string describing the type of this mixer and the name of <see cref="P:Animancer.MixerState.Clip"/>s connected to it.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)"/> to append the details of this node.</summary>
        </member>
        <member name="M:Animancer.MixerState.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in this state.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.MixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.CreateDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.MixerState.Drawer`1"/> for this state.</summary>
        </member>
        <member name="T:Animancer.MixerState.Drawer`1">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.MixerState"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState.Drawer`1.#ctor(`0)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState.Drawer`1"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.Drawer`1.ParameterCount">
            <summary>The number of parameters being managed by the target state.</summary>
        </member>
        <member name="M:Animancer.MixerState.Drawer`1.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.Drawer`1.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.Drawer`1.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.Drawer`1.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.Drawer`1.AddContextMenuFunctions(UnityEditor.GenericMenu)">
            <summary>Adds the details of this state to the `menu`.</summary>
        </member>
        <member name="T:Animancer.MixerState.Transition`2">
            <summary>
            Base class for serializable <see cref="T:Animancer.ITransition"/>s which can create a particular type of
            <see cref="T:Animancer.MixerState`1"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
            <remarks>
            Unfortunately the tool used to generate this documentation does not currently support nested types with
            identical names, so only one <c>Transition</c> class will actually have a documentation page.
            <para></para>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.MixerState.Transition`2.Thresholds">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The parameter values at which each of the states are used and blended.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.Transition`2.DefaultParameter">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The initial parameter value to give the mixer when it is first created.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.Transition`2.InitialiseState">
            <summary>
            Initialises the <see cref="P:Animancer.AnimancerState.Transition`1.State"/> immediately after it is created.
            </summary>
        </member>
        <member name="T:Animancer.MixerState.Transition2D">
            <summary>
            A serializable <see cref="T:Animancer.ITransition"/> which can create a <see cref="T:Animancer.CartesianMixerState"/> or
            <see cref="T:Animancer.DirectionalMixerState"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
        </member>
        <member name="T:Animancer.MixerState.Transition2D.MixerType">
            <summary>
            A type of <see cref="T:Animancer.MixerState"/> that can be created by a <see cref="T:Animancer.MixerState.Transition2D"/>.
            </summary>
        </member>
        <member name="F:Animancer.MixerState.Transition2D.MixerType.Cartesian">
            <summary><see cref="T:Animancer.CartesianMixerState"/></summary>
        </member>
        <member name="F:Animancer.MixerState.Transition2D.MixerType.Directional">
            <summary><see cref="T:Animancer.DirectionalMixerState"/></summary>
        </member>
        <member name="P:Animancer.MixerState.Transition2D.Type">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The type of <see cref="T:Animancer.MixerState"/> that this transition will create.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.Transition2D.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.CartesianMixerState"/> or <see cref="T:Animancer.DirectionalMixerState"/>
            depending on the <see cref="P:Animancer.MixerState.Transition2D.Type"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method
            as well. Or you can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Transition`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.MixerState.Transition2D.Drawer">
            <summary>[Editor-Only]
            Draws the Inspector GUI for a <see cref="T:UnityEngine.Vector2"/> <see cref="T:Animancer.MixerState.Transition`2"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.Transition2D.Drawer.#ctor">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState.Transition2D.Drawer"/> using the a wider `thresholdWidth` than usual to accomodate
            both the X and Y values.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.Transition2D.Drawer.HasThresholdContextMenu">
            <summary><see cref="M:Animancer.MixerState.Transition2D.Drawer.AddThresholdFunctionsToMenu(UnityEditor.GenericMenu)"/> will add some functions to the menu.</summary>
        </member>
        <member name="M:Animancer.MixerState.Transition2D.Drawer.AddThresholdFunctionsToMenu(UnityEditor.GenericMenu)">
            <summary>Adds functions to the `menu` relating to the thresholds.</summary>
        </member>
        <member name="T:Animancer.MixerState.TransitionDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.MixerState.Transition`2"/>.</summary>
            <remarks>
            This class would be nested inside <see cref="T:Animancer.MixerState.Transition`2"/>, but the generic parameters
            cause problems in Unity 2019.3.
            </remarks>
        </member>
        <member name="F:Animancer.MixerState.TransitionDrawer.ThresholdWidth">
            <summary>
            The number of horizontal pixels the "Threshold" label occupies.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.TransitionDrawer.StandardThresholdWidth">
            <summary>
            The number of horizontal pixels the word "Threshold" occupies when drawn with the
            <see cref="P:UnityEditor.EditorStyles.popup"/> style.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.#ctor">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState.TransitionDrawer"/> using the default <see cref="P:Animancer.MixerState.TransitionDrawer.StandardThresholdWidth"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.#ctor(System.Single)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState.TransitionDrawer"/> using a custom width for its threshold labels.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.TransitionDrawer.CurrentThresholds">
            <summary>
            The serialized <see cref="P:Animancer.MixerState.Transition`2.Thresholds"/> of the
            <see cref="P:Animancer.ManualMixerState.Transition.Drawer.CurrentProperty"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.GatherSubProperties(UnityEditor.SerializedProperty)">
            <summary>
            Called every time a `property` is drawn to find the relevant child properties and store them to be
            used in <see cref="M:Animancer.ManualMixerState.Transition.Drawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> and
            <see cref="M:Animancer.ManualMixerState.Transition.Drawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.SplitListRect(UnityEngine.Rect,System.Boolean,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>Splits the specified `area` into separate sections.</summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.DoStateListHeaderGUI(UnityEngine.Rect)">
            <summary>Draws the headdings of the state list.</summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.DoElementGUI(UnityEngine.Rect,System.Int32,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Draws the GUI of the state at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.DoThresholdGUI(UnityEngine.Rect,System.Int32)">
            <summary>Draws the GUI of the threshold at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.OnAddElement(UnityEditorInternal.ReorderableList)">
            <summary>
            Called when adding a new state to the list to ensure that any other relevant arrays have new
            elements added as well.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.OnRemoveElement(UnityEditorInternal.ReorderableList)">
            <summary>
            Called when removing a state from the list to ensure that any other relevant arrays have elements
            removed as well.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.OnReorderList(UnityEditorInternal.ReorderableList,System.Int32,System.Int32)">
            <summary>
            Called when reordering states in the list to ensure that any other relevant arrays have their
            corresponding elements reordered as well.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.TransitionDrawer.HasThresholdContextMenu">
            <summary>Indicates whether <see cref="M:Animancer.MixerState.TransitionDrawer.AddThresholdFunctionsToMenu(UnityEditor.GenericMenu)"/> will add anything to the menu.</summary>
        </member>
        <member name="M:Animancer.MixerState.TransitionDrawer.AddThresholdFunctionsToMenu(UnityEditor.GenericMenu)">
            <summary>Adds functions to the `menu` relating to the thresholds.</summary>
        </member>
        <member name="T:Animancer.MixerState`1">
            <summary>[Pro-Only]
            Base class for mixers which blend an array of child states together based on a <see cref="P:Animancer.MixerState`1.Parameter"/>.
            </summary>
        </member>
        <member name="F:Animancer.MixerState`1.NoParameters">
            <summary>An empty array of parameter values.</summary>
        </member>
        <member name="F:Animancer.MixerState`1._Thresholds">
            <summary>The parameter values at which each of the child states are used and blended.</summary>
        </member>
        <member name="P:Animancer.MixerState`1.Parameter">
            <summary>The value used to calculate the weights of the child states.</summary>
        </member>
        <member name="P:Animancer.MixerState`1.HasThresholds">
            <summary>
            Indicates whether the array of thresholds has been initialised with a size at least equal to the
            <see cref="P:Animancer.AnimancerNode.ChildCount"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.GetThreshold(System.Int32)">
            <summary>
            Returns the value of the threshold associated with the specified index.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.SetThreshold(System.Int32,`0)">
            <summary>
            Sets the value of the threshold associated with the specified index.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.SetThresholds(`0[])">
            <summary>
            Assigns the specified array as the thresholds to use for blending.
            <para></para>
            WARNING: if you keep a reference to the `thresholds` array you must call <see cref="M:Animancer.MixerState`1.OnThresholdsChanged"/>
            whenever any changes are made to it, otherwise this mixer may not blend correctly.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.ValidateThresholdCount">
            <summary>
            If the <see cref="P:System.Array.Length"/> of the <see cref="F:Animancer.MixerState`1._Thresholds"/> is not equal to the
            <see cref="P:Animancer.AnimancerNode.ChildCount"/>, this method assigns a new array of that size and returns true.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. By default this method simply indicates that the blend weights
            need recalculating but it can be overridden by child classes to perform validation checks or optimisations.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.CalculateThresholds(System.Func{Animancer.AnimancerState,`0})">
            <summary>
            Calls `calculate` for each of the <see cref="F:Animancer.ManualMixerState._States"/> and stores the returned value as
            the threshold for that state.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.RecreatePlayable">
            <summary>
            Stores the values of all parameters, calls <see cref="M:Animancer.AnimancerNode.DestroyPlayable"/>, then restores the
            parameter values.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Initialise(System.Int32)">
            <summary>
            Initialises this mixer with the specified number of ports which can be filled individually by
            <see cref="M:Animancer.MixerState.CreateChild(System.Int32,UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Initialise(UnityEngine.AnimationClip[],`0[])">
            <summary>
            Initialises the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> and <see cref="F:Animancer.ManualMixerState._States"/> with one
            state per clip and assigns the `thresholds`.
            <para></para>
            WARNING: if you keep a reference to the `thresholds` array, you must call
            <see cref="M:Animancer.MixerState`1.OnThresholdsChanged"/> whenever any changes are made to it, otherwise this mixer may not blend
            correctly.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Initialise(UnityEngine.AnimationClip[],System.Func{Animancer.AnimancerState,`0})">
            <summary>
            Initialises the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> and <see cref="F:Animancer.ManualMixerState._States"/> with one
            state per clip and assigns the thresholds by calling `calculateThreshold` for each state.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.CreateChild(System.Int32,UnityEngine.AnimationClip,`0)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` with this
            <see cref="T:Animancer.MixerState"/> as its parent, connects it to the specified `index`, and assigns the
            `threshold` for it.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.CreateChild(System.Int32,Animancer.ITransition,`0)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>, sets this mixer as the state's parent, and
            assigns the `threshold` for it.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.SetChild(System.Int32,Animancer.AnimancerState,`0)">
            <summary>Assigns the `state` as a child of this mixer and assigns the `threshold` for it.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.GetDisplayKey(Animancer.AnimancerState)">
            <summary>Gets a user-friendly key to identify the `state` in the Inspector.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.Int32,System.String)"/> to append the details of this node.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.AppendParameter(System.Text.StringBuilder,`0)">
            <summary>Appends the `parameter` in a viewer-friendly format.</summary>
        </member>
    </members>
</doc>
